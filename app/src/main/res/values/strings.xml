<resources>
    <string name="app_name">JavaApp</string>
    <string name="main">Главная</string>
    <string name="basics_bottom">Основы</string>
    <string name="oop_bottom">ООП</string>
    <string name="collections_bottom">Коллекции</string>
    <string name="other_bottom">Другое</string>
    <string name="basics_java">Основы JAVA</string>
    <string name="frag_01_oracle"><b>Java</b> - это объектно-ориентирован-\nный язык программирования, разработанный компанией Sun Microsystems в 1990-х годах (позже купленной Oracle).\n Понятие «объектно-ориентирован-\nный» относится к способу написания структурного кода Java, а именно: разделение кода на так называемые «классы», которые запускаются вместе, чтобы обеспечить согласованное порождение объектов. Мы обсудим это позже, но достаточно сказать, что это приводит к универсальному и организованному коду, который легко редактировать и перепрофилировать.</string>
    <string name="what_is_java"><u>Что такое Java?</u></string>
    <string name="frag_01_oracle02"><b>Java</b> была разработана Джеймсом Гослингом, Патриком Нотоном, Майком Шериданом в Sun Microsystems Inc. <b>в 1991</b> году.\n На разработку первой рабочей версии ушло 18 месяцев. Первоначальное название было Oak (ДУБ), но в 1995 году оно было переименовано в Java, так как OAK был зарегистрированной торговой маркой другой технологической компании.</string>
    <string name="create_java"><u>Создание Java</u></string>
    <string name="frag_01_oracle03"><b>Java</b> широко используется во всех уголках мира и человеческой жизни.\n Java не только используется в программном обеспечении, но и широко используется при проектировании аппаратных средств управления программными компонентами.\n Существует более 930 миллионов загрузок JRE каждый год, и 3 миллиарда мобильных телефонов работают на java.\n \nНиже приведены некоторые другие варианты использования Java:\n 1) Разработка настольных приложений\n 2) Веб-приложения, такие как Linkedin.com, Snapdeal.com и.т.д.\n 3) Мобильная операционная система, такая как Android встроенная система\n 4)Робототехника и игры и.т.д.</string>
    <string name="application_java"><u>Применение Java</u></string>
    <string name="frag_01_oracle04"><b>1) Автономное приложение</b>\n \nАвтономные приложения - это приложения, которые работают на отдельном компьютерном процессе без добавления каких-либо файловых процессов.\n Автономное приложение также известно как Java GUI-приложения или настольные приложения, которые используют некоторые стандартные компоненты GUI, такие как AWT(Abstract Windowing Toolkit), swing и JavaFX, и этот компонент развертывается на рабочем столе.\n Эти компоненты имеют кнопки, меню, таблицы, инструментарий виджетов GUI, 3D-графику и т. д. с помощью этого компонента разрабатывается традиционное программное обеспечение, которое может быть установлено на любой машине.\n \n<b>Пример:</b> медиаплеер, антивирус, краска, программное обеспечение для биллинга POS и.т.д.\n \n <b>2) Веб-приложение</b>\n \n Веб-приложения - это клиент-серверное программное приложение, которое запускается клиентом.\n Сервлеты, стойки, JSP, Spring, hibernate и.т.д. используются для разработки клиент-серверного приложения. приложение электронной коммерции также разработано на java с использованием платформы электронной коммерции Broadleaf.\n \n<b>Пример:</b> почта, сайт электронной коммерции, сайт банка и.т.д.\n \n <b>3) Корпоративное приложение</b>\n  \nКорпоративное приложение-это промежуточное программное обеспечение.\n Использовать программные и аппаратные комплексы, технологии и сервисы на всех предприятиях. Он предназначен для корпоративной области, такой как банковские бизнес-системы.\n \n <b>Пример:</b> электронная коммерция, бухгалтерия, банковские информационные системы и.т.д.\n \n <b>4) Мобильное приложение</b>\n \n Для мобильных приложений Java использует фреймворк ME или J2ME.\n Эта платформа представляет собой кросс-платформу, которая запускает приложения на телефонах и смартфонах.\n Java также предоставляет платформу для разработки приложений в Android.\n \n<b>Пример:</b> WhatsApp, Xender и.т.д</string>
    <string name="type_java_app"><u>Типы Java-приложений</u> </string>
    <string name="features_java"><u>Особенности JAVA</u></string>
    <string name="frag_01_oracle05">Основная причина создания Java заключалась в том, чтобы привнести в компьютерный язык функцию переносимости и безопасности.\n Помимо этих двух основных особенностей, было много других особенностей, которые сыграли важную роль в формировании окончательной формы этого выдающегося языка.\n Эти особенности таковы :\n \n<b>1) Простой</b>\n \n Java проста в освоении, а ее синтаксис довольно прост, чист и понятен.\nЗапутанные и двусмысленные концепции C++ либо оставлены в Java, либо они были повторно реализованы более чистым способом. \n<b>Например:</b> указатели и перегрузка операторов не существуют в java, но были важной частью C++.\n \n <b>2) Объектно-Ориентированный</b>\n \n В java все является объектом, который имеет некоторые данные и поведение.\n Java может быть легко расширена, так как она основана на объектной модели. \nНиже приведены некоторые основные концепции ООП:\n Объект, Класс, Наследование, Полиморфизм, Абстракция, Инкапсуляция.\n \n <b>3) Робастный</b>\n \n Java прилагает усилия для устранения подверженных ошибкам кодов, делая акцент главным образом на проверке ошибок во время компиляции и проверке времени выполнения.\n Но основными областями, которые улучшила Java, были управление памятью и неправильное обращение с исключениями, введя автоматический сборщик мусора и обработку исключений.\n \n <b>4) Независимый</b>\n \n От Платформы В отличие от других языков программирования, таких как C, C++ и т.д., которые компилируются в специфичные для платформы машины.\n Java гарантированно будет писать-один раз, запускать-в любом месте языка. При компиляции Java-программа компилируется в байт-код.\n Этот байт-код не зависит от платформы и может быть запущен на любой машине, плюс этот формат байт-кода также обеспечивает безопасность.\n Любая машина с Java Runtime Environment может запускать Java-программы.</string>
    <string name="frag_01_oracle06"> <b>5) Безопасный</b>\n \n Когда дело доходит до безопасности, Java всегда является первым выбором.\n С помощью java secure features он позволяет нам разрабатывать безвирусную, свободную от темперамента систему.\n Java-программа всегда работает в среде Java runtime environment с почти нулевым взаимодействием с системной ОС, поэтому она более безопасна. \n \n <b>6) Многопоточность</b>\n \n Функция многопоточности Java позволяет писать программы, которые могут выполнять множество задач одновременно.\n Преимущество многопоточности заключается в том, что она использует одну и ту же память и другие ресурсы для выполнения нескольких потоков одновременно, например, при наборе текста проверяются грамматические ошибки.\n \n <b>7) Архитектурноакустическая Нейтраль</b>\n \n Компилятор генерирует байт-коды, которые не имеют ничего общего с конкретной архитектурой компьютера, поэтому Java-программу легко внедрить на любой машине.\n \n <b>8) Портативный</b>\n \n Байтовый код Java может быть перенесен на любую платформу.\n Никаких функций, зависящих от реализации. Все, что связано с хранилищем, предопределено заранее, <b>например:</b> размер примитивных типов данных\n \n <b>9) Высокая Производительность</b>\n \n Java-это интерпретируемый язык, поэтому он никогда не будет таким быстрым, как скомпилированный язык, такой как C или c++. \nНо Java обеспечивает высокую производительность при использовании компилятора just-in-time.\n \n <b>10) Распределенные</b>\n \n Java также является распределенным языком. Программы могут быть разработаны для работы в компьютерных сетях.\n Java имеет специальную библиотеку классов для связи с использованием протоколов TCP / IP.\n Создание сетевых подключений очень просто в Java по сравнению с C/C++.</string>
    <string name="strip">_____________</string>
    <string name="fragment02_01"><b>Объект</b> — объекты имеют состояние и поведение. Например: собака может иметь состояние — цвет, имя, а также и поведение — кивать, бежать, лаять, кушать. Объект является экземпляром класса</string>
    <string name="fragment02_02"><b>Класс</b> – это компонент языка Java, из которого создаются отдельные объекты</string>
    <string name="fragment02_03"><b>Пакет</b> – это папка (или несколько папок) на диске, в которой хранятся классы</string>
    <string name="fragment02_04"><b>Объявление класса</b> – это создание в программе нового класса</string>
    <string name="fragment02_05"><b>Переменная</b> – в программировании это практически то же самое, что и в алгебре.\n Переменная может хранить в себе значение, которое можно изменять и использовать</string>
    <string name="fragment02_06"><b>Объявление метода</b> – это создание в программе нового метода</string>
    <string name="fragment02_07"><b>Аргумент метода</b> – это переменная, в которую записываются значения, передаваемые методу при его вызовах (использовании)</string>
    <string name="fragment02_08"><b>Консоль</b> – это пульт управления программой. Она представляется в виде окна, в которое программой выводится информация или вводится пользователем</string>
    <string name="fragment02_09"><b>Объявление переменной</b> – создание новой переменной в программе. Ей задается своё уникальное имя и выделяется под нее память</string>
    <string name="fragment02_10"><b>Инициализация переменной</b> – установка значения переменной, если она его еще не имеет</string>
    <string name="fragment02_11"><b>Простой тип переменных</b> – тип переменных, содержащий в себе определенное значение. \nКроме простого типа есть еще ссылочный, который хранит в себе ссылку на объект</string>
    <string name="fragment02_12"><b>Оператор</b> – это то, что оперирует чем-то (выполняет какие-либо операции над чем-то)</string>
    <string name="fragment02_13"><b>Литерал</b> – какое-либо конкретное значение, указанное в коде программы</string>
    <string name="fragment02_14"><b>Массив</b> - является объектом, который хранит несколько переменных одного и того же типа</string>
    <string name="fragment02_15"><b>Ссылочный тип переменной</b>– это тип переменных, которые хранят в себе ссылку на объект</string>
    <string name="fragment02_16"><b>Конструктор</b> – фактически, это метод класса, имеющий точно такое же название, как и класс, но не имеющий типа возвращаемого значения</string>
    <string name="fragment02_17"><b>Импорт классов</b> – добавление других классов в наш класс для получения возможности использования этих классов</string>
    <string name="fragment02_18"><b>Среда разработки</b> – программа, предназначенная для разработки других программ</string>
    <string name="fragment02_19"><b>Операнд</b> – это часть выражения, над которой какой-либо оператор проводит операции</string>
    <string name="fragment02_20"><b>Приведение типа</b> – это преобразование значения переменной из одного типа в другой</string>
    <string name="fragment02_21"><b>Статический метод</b> (или переменная) – это метод (или переменная), которая принадлежит классу, а не его объекту и не требует объекта для своего использования</string>
    <string name="fragment02_22"><b>Сборщик мусора</b> – это подсистема Java, отвечающая за удаление неиспользуемых объектов</string>
    <string name="fragment02_23"><b> Пустая строка</b> — строки в Java, содержащие только пробелы, возможно с комментарием</string>
    <string name="fragment02_24"><b>Наследование</b> — концепция, которая позволяет повторно воспользоваться полями и методами существующего класса без необходимости переписывать заново код</string>
    <string name="fragment02_25"><b>Интерфейс</b> в Java может быть определен как договор между объектами о том, как общаться друг с другом.\n Интерфейс определяет методы, полученного класса (подкласса), и как их следует использовать</string>
    <string name="explanations"><u>Пояснения</u></string>
    <string name="syntax_java"><b>Очень важно знать и помнить следующие моменты в синтаксисе:</b>\n-<b>Чувствительность к регистру</b>\n Java чувствителен к регистру, то есть идентификатор <b>Hello</b> и <b>hello</b> имеют разный смысл. \n \n -<b>Название классов</b>\n Для всех первая буква должна быть в верхнем регистре.\n \n -Если несколько слов используются, чтобы сформировать название класса, первая буква каждого внутреннего слова должна быть в верхнем регистре, например, <b>«MyJavaClass»</b>.\n \n -<b>Название методов</b> \n В синтаксисе Java все имена методов должны начинаться с буквы нижнего регистра.\n \n -Если несколько слов используются, чтобы сформировать имя метода, то <b>первая буква</b> каждого внутреннего слова должна быть в верхнем регистре, например, «public void <b>myMethodName</b>()».\n \n -<b>Название файла программы</b> \n Наименование файла программы должно точно совпадать с именем класса.\n \n -При сохранении файла, Вы должны сохранить его, используя имя класса и добавить «.java» в конце имени, например, «MyJavaProgram» — это название класса, тогда файл должен быть сохранен как <b>«MyJavaProgram.java»</b>Если имена не совпадают, Ваша программа не будет компилироваться \n \n  -<b>public static void main(String args[])</b>\n Обработка программы начинается с метода <b>main()</b>, который является обязательной частью каждой программы.</string>
    <string name="identifier"><b>Идентификаторы</b> — имена, используемые для классов, переменных и методов.\n Все компоненты Java требуют имена.\n Существует несколько правил в синтаксисе языка Java, которые необходимо помнить об идентификаторе.\n \n <b>Они следующие:</b>\n -Каждый идентификатор должен начинаться с <b>«A» до «Z»</b> или <b>«a» до «z»</b>, <b>«$» или «_»</b>.\n \n -После первого символа может иметь любую комбинацию символов. \n \n -Ключевое слово не может быть использовано в качестве идентификатора. \n \n -Самое главное — идентификатор в Java чувствителен к регистру. \n \n -Пример правильного написания: <b>age, $salary, _value, __1_value</b>. \n \n -Пример неправильного написания: <b>123abc, -salary</b>.</string>
    <string name="type_per_java">Далее в Java мы увидим следующие существующие типы:\n \n -Локальные переменные. \n \n -Переменные класса (статические). \n \n -Переменные экземпляра (динамические).</string>
    <string name="mod_java">Как и в других языках, в Java можно модифицировать классы, методы и так далее, с помощью модификаторов.\n \n <b>Модификаторы в Java делится на две категории:</b> \n \n -С доступом: default, public, protected, private. \n \n -Без доступа: final, abstract, strictfp.</string>
    <string name="fifty_java">Всего зарезервировано <b>50 ключевых слов в Java</b>.\n Ниже в таблице приведен список зарезервированных ключевых слов.</string>
    <string name="basic_sin_java"><u>Основы синтаксиса языка Java</u></string>
    <string name="identifier_java"><u>Идентификаторы в Java</u></string>
    <string name="type_variables"><u>Типы переменных</u></string>
    <string name="modificators"><u>Модификаторы</u></string>
    <string name="crucial_words"><u>Ключевые слова в Java</u></string>
    <string name="one_lessons"><u>Первая программа</u></string>
    <string name="less_one1">Создание программы <b>Hello World</b> на Java-это не однострочная программа. Он состоит из различных других строк кода.\n Поскольку Java-это объектно-ориентированный язык, поэтому он требует написания кода внутри класса.</string>
    <string name="less_one_02"><b>Давайте разберемся, из чего состоит вышеприведенная программа и ее ключевые точки.\n \n </b>\n <b>class:</b> ключевое слово class используется для объявления классов в Java\n \n <b>public:</b> это спецификатор доступа. Публичность означает, что эта функция видна всем.\n \n <b>static:</b> static - это снова ключевое слово, используемое для того, чтобы сделать функцию статичной. Для выполнения статической функции вам не нужно создавать объект класса.\n \nМетод main() здесь вызывается JVM, без создания какого-либо объекта для класса.\n \n<b>void:</b> это тип возвращаемого значения, то есть эта функция ничего не вернет.\n \n <b>main: метод main ()</b> является наиболее важным методом в программе Java. Это метод, который выполняется, следовательно, вся логика должна быть внутри метода main ().\n Если класс java не имеет метода main (), это вызывает ошибку компиляции.\n \n<b>String[] args:</b> это представляет собой массив, тип которого-String, а имя-args. Подробнее об массиве мы поговорим в разделе Java Array.\n \n <b>Система.из.println:</b> это используется для печати чего-либо на консоли.\n Данная команда просто выводит строку в скобках на экран. В конце используется оператор <b>точка с запятой</b>.\n Таким образом в Java указывается конец выражения или строки кода. Значение, которое нужно вывести в качестве результата, заключается в кавычки. </string>
    <string name="pictures_less_one">pictures_less_one</string>
    <string name="steps_start_hello_java">Шаги по компиляции и запуску вашей первой Java-программы</string>
    <string name="less_one_03"><b>Шаг 1:</b>\n Откройте текстовый редактор и напишите код, как указано на скриншоте выше.\n \n <b>Шаг 2:</b>\n Сохраните файл как Hello.java\n \n <b>Шаг 3:</b> \nОткройте командную строку и перейдите в каталог, где вы сохранили свою первую программу java.\n \n <b>Шаг 4:</b> \nТип javac Hello.java и нажмите кнопку Return(ввод) чтобы скомпилировать ваш код.\n Эта команда вызовет компилятор Java с просьбой скомпилировать указанный файл.\n Если в коде нет ошибок, то командная строка выведет вас на следующую строку.\n \n <b>Шаг 5:</b> \nТеперь наберите java Hello в командной строке запустите свою программу.\n \n <b>Шаг 6:</b>\n Вы сможете увидеть программа <b>Hello world</b> печатается в командной строке. \n \n Конечно,  для написания, компилирования и запуска программ на языке Java существуют более удобный инструмент, нежели Блокнот и командная строка . Этот так называемая <b>Интегрированная среда обработки (IDE)</b>.\n К примеру <b>Eclipse IDE</b> или <b>Intellij IDEA </b>.</string>
    <string name="previous_btn">Предыдущий</string>
    <string name="next_btn">Следующий</string>
    <string name="lessons_btn">К урокам</string>
    <string name="variables"><u>Переменные и Константы</u></string>

    <string name="lesson_three_type_data"><u>Типы данных</u></string>
    <string name="less_three_01">Язык <b>Java</b> имеет богатую реализацию типов данных. Типы данных определяют размер и тип значений, которые могут храниться в идентификаторе.\n \n В java типы данных подразделяются на <b>две</b> категории :\n1)Примитивный тип данных \n2)Непримитивный тип данных </string>


    <string name="lessons03_03">Примитивный тип данных может быть <b>восьми</b> типов: boolean, byte, short, int, long, double, float, char.\n \n-<b>boolean</b>: хранит значение <b>true</b> или <b>false</b></string>
    <string name="lessons03_04">-<b>byte</b>: хранит целое число от <b>-128</b> до <b>127</b> и занимает <b>1 байт</b></string>
    <string name="lessons03_05">-<b>short</b>: хранит целое число от <b>-32768</b> до <b>32767</b> и занимает <b>2 байта</b></string>
    <string name="lessons03_06">-<b>int</b>: хранит целое число от <b>-2147483648</b> до <b>2147483647</b> и занимает <b>4 байта</b></string>
    <string name="lessons03_07">-<b>long</b>: хранит целое число от <b>–9 223..(Очень длинное число)</b> до <b>9 223..</b> и занимает <b>8 байт</b></string>
    <string name="lessons03_08">-<b>double</b>: хранит число с плавающей точкой и занимает <b>8 байт</b></string>
    <string name="lessons03_09">В качестве разделителя целой и дробной части в дробных литералах используется <b>точка</b>.\n \n-<b>float</b>:тоже хранит число с плавающей точкой от и занимает <b>4 байта</b></string>
    <string name="lessons03_10">После ввода значения пишется суффикс <b>F</b>.</string>
    <string name="lessons03_11">-<b>char</b>: хранит одиночный символ в кодировке <b>UTF-16</b> и занимает <b>2 байта</b>, поэтому диапазон хранимых значений от <b>0 до 65535</b></string>
    <string name="lessons03_12">При этом переменная может принимать только те значения, которые соответствуют ее типу. Если переменная представляет целочисленный тип, то она не может хранить дробные числа</string>
    <string name="lessons03_14">В первой строчке переменной <b>String</b> по имени hello присваивается строковое значение <b>Hello..</b>\n \n Во второй строчке с помощью команды <b>System.out.println</b> переменная hello выводится в консоль</string>
    <string name="lessons03_13">Непримитивный <b>(ссылочный)</b> используется для ссылки на объект.\n \nСсылочная переменная объявляется определенной, и этот тип никогда не может быть изменен.\n \n Ссылочный тип используется для хранения ссылки на объект.\n Объект может быть экземпляром любого класса или сущности.\n\n<b>String</b>-это класс в Java и всегда пишется с заглавной буквы.</string>
    <string name="primitive_type"><u>Примитивный тип</u></string>
    <string name="non_primitive_type"><u>Непримитивный тип</u></string>
    <string name="other_themes">Прочие темы</string>
    <string name="collections">Коллекции</string>
    <string name="lessons01_01">Первая программа</string>
    <string name="lessons01_02">Основным строительным блоком программы на языке Java являются <b>инструкции</b>. \nКаждая инструкция выполняет некоторое действие, например, вызовы методов, объявление переменных и присвоение им значений. \n\nПосле завершения инструкции в Java ставится <b>точка с запятой (;)</b>.\n Данный знак указывает компилятору на конец инструкции.\n \n Например:</string>
    <string name="lessons01_03">Данная строка представляет вызов метода <b>System.out.println</b>, который выводит на консоль строку <b>Hello Java!</b> \nВ данном случае вызов метода является инструкцией и поэтому завершается точкой с запятой. \n \nКроме отдельных инструкций распространенной конструкцией является блок кода.\n Блок кода содержит набор инструкций, он заключается в <b>фигурные скобки</b>, а инструкции помещаются между открывающей и закрывающей фигурными скобками:</string>
    <string name="less01_image01">Скриншот01</string>
    <string name="less01_image02">Скриншот02</string>
    <string name="lessons01_04">В этом блоке кода <b>две инструкции</b>, которые выводят на консоль определенную строку.</string>
    <string name="lessons01_05">Выполнение программы. Метод main</string>
    <string name="lessons01_06">Java является <b>объектно-ориентированным языком</b>, поэтому всю программу можно представить как набор взаимодействующих между собой классов и объектов.\nПрограмма может быть определена следующим образом:</string>
    <string name="less01_image03">Скриншот03</string>
    <string name="lessons01_07">То есть основу нашей программы составляет класс <b>Program</b>.\n\nПри определении класса вначале идет модификатор доступа <b>public</b>, который указывает, что данный класс будет доступен всем, то есть мы сможем его запустить из командной строки.\n \nДалее идет ключевое слово <b>class</b>, а затем название класса.\n После названия класса идет блок кода, в котором расположено содержимое класса.\n \n Входной точкой в программу на языке Java является метод <b>main</b>, который определен в классе <b>Program</b>.\n \n Именно с него начинается выполнение программы. Он обязательно должен присутствовать в программе.\n\n При этом его заголовок может быть только таким:</string>
    <string name="less01_image04">Скриншот05</string>
    <string name="lessons01_08">При запуске приложения виртуальная машина Java ищет в главном классе программы метод <b>main</b> с подобным заголовком, и после его обнаружения запускает его.\n\nВначале заголовка метода идет модификатор <b>public</b>, который указывает, что метод будет доступен извне.\n\n Слово <b>static</b> указывает, что метод main - статический, а слово <b>void</b> - что он не возвращает никакого значения.\n \nДалее в скобках у нас идут параметры метода <b>String args[]</b> - это массив args, который хранит значения типа <b>String</b>, то есть строки.\n\n При запуске программы через этот массив мы можем передать в программу различные данные.\n После заголовка метода идет его блок, который содержит набор выполняемых инструкций.</string>
    <string name="lessons01_09">Комментарии</string>
    <string name="lessons01_10">Код программы может содержать <b>комментарии</b>.\n\n Комментарии позволяют понять смысл программы, что делают те или иные ее части.\n При компиляции комментарии игнорируются и не оказывают никакого влияния на работу приложения и на его размер.\n \n В Java есть <b>два типа комментариев:</b> однострочный и многострочный.\n -Однострочный комментарий размещается на одной строке после двойного слеша <b>//</b>.\n-А многострочный комментарий заключается между символами <b>/* текст комментария */</b>.\n Он может размещаться на нескольких строках. \n\nНапример:</string>
    <string name="less01_image05">Скриншот05</string>
    <string name="lessons02_01">Для хранения данных в программе предназначены <b>переменные</b>.\nПеременная представляет именованную область памяти, которая хранит значение определенного типа.\n\nКаждая переменная имеет <b>тип, имя</b> и <b>значение</b>.\nТип определяет, какую информацию может хранить переменная или диапазон допустимых значений.\n\nПеременные объявляются следующим образом:</string>
    <string name="less02_image01">Скриншот01_урок02</string>
    <string name="lessons02_02">В этом выражении мы объявляем переменную <b>x</b> типа <b>int</b>.\nТо есть x будет хранить некоторое число не больше <b>4 байт</b>\n\n В качестве имени переменной может выступать любое произвольное название, которое удовлетворяет следующим требованиям:\n\n-имя может содержать любые алфавитно-цифровые символы, а также знак подчеркивания, при этом первый символ в имени не должен быть цифрой \n\n-в имени не должно быть знаков пунктуации и пробелов \n\n-имя не может быть ключевым словом языка Java\n\nКроме того, при объявлении и последующем использовании надо учитывать, что Java - регистрозависимый язык, поэтому следующие объявления <b>int num;</b> и <b>int NUM;</b> будут представлять две разных переменных\n\nОбъявив переменную, мы можем присвоить ей значение:</string>
    <string name="less02_image02">Скриншот02_урок02</string>
    <string name="lessons02_03">Также можно присвоить значение переменной при ее объявлении.\n Этот процесс называется <b>инициализацией</b>:</string>
    <string name="less02_image03">Скриншот03_урок02</string>
    <string name="less02_image04">Скриншот04_урок02</string>
    <string name="lessons02_04">Если мы не присвоим переменной значение до ее использования, то мы можем получить <b>ошибку</b>, например, в следующем случае:</string>
    <string name="less02_image05">Скриншот05_урок02</string>
    <string name="lessons02_05">Через запятую можно объявить сразу несколько переменных одного типа:</string>
    <string name="lessons02_06">Также можно их сразу инициализировать:</string>
    <string name="less02_image06">Скриншот06_урок02</string>
    <string name="less02_image07">Скриншот07_урок02</string>
    <string name="lessons02_07">Отличительной особенностью переменных является то, что мы можем в процессе работы программы изменять их значение:</string>
    <string name="var"><u>Ключевое слово var</u></string>
    <string name="less02_image08">Скриншот08_урок02</string>
    <string name="lessons02_08">Начиная с Java 10 в язык было добавлено ключевое слово <b>var</b>, которое также позволяет определять переменную:</string>
    <string name="lessons02_09">Слово <b>var</b> ставится вместо типа данных, а сам тип переменной выводится из того значения, которое ей присваивается.\n\nНапример, переменной <b>x</b> присваивается число <b>10</b>, значит, переменная будет представлять тип <b>int</b>.\n\nНо если переменная объявляется с помощью <b>var</b>, то мы обязательно должны инициализировать ее, то есть предоставить ей начальное значение, иначе мы получим ошибку, как, например, в следующем случае:</string>
    <string name="less02_image09">Скриншот09_урок02</string>
    <string name="less02_image10">Скриншот08_урок02</string>
    <string name="constants"><u>Константы</u></string>
    <string name="lessons02_10">Кроме переменных, в Java для хранения данных можно использовать <b>константы</b>.\n\n В отличие от переменных константам можно присвоить значение только один раз.\n\n Константа объявляется также, как и переменная, только вначале идет ключевое слово <b>final</b>:</string>
    <string name="lessons02_11">Как правило, константы имеют имена в верхнем регистре.\nКонстанты позволяют задать такие переменные, которые не должны больше изменяться.\n\nНапример, если у нас есть переменная для хранения числа <b>pi</b>, то мы можем объявить ее константой, так как ее значение постоянно.</string>
    <string name="less03_image01">Скриншот01_урок03</string>
    <string name="less03_image02">Скриншот02_урок03</string>
    <string name="less03_image03">Скриншот03_урок03</string>
    <string name="less03_image04">Скриншот04_урок03</string>
    <string name="less03_image05">Скриншот05_урок03</string>
    <string name="less03_image06">Скриншот06_урок03</string>
    <string name="less03_image07">Скриншот07_урок03</string>
    <string name="less03_image08">Скриншот08_урок03</string>
    <string name="less03_image09">Скриншот09_урок03</string>

    <string name="Consol"><u>Консольный ввод</u></string>
    <string name="lessons04_01">Наиболее простой способ взаимодействия с пользователем представляет <b>консоль</b>: мы можем выводить на консоль некоторую информацию или, наоборот, считывать с консоли некоторые данные.\n\nДля взаимодействия с консолью в Java применяется класс <b>System</b>, а его функциональность собственно обеспечивает консольный ввод и вывод.</string>
    <string name="lessons04_02"><u>Вывод на консоль</u></string>
    <string name="lessons04_03">Для создания потока вывода в класс <b>System</b> определен объект <b>out</b>.\n\nВ этом объекте определен метод <b>println</b>, который позволяет вывести на консоль некоторое значение с последующим переводом курсора консоли <b>на следующую строку</b>. \n\nНапример:</string>
    <string name="lessons04_04">В метод <b>println</b> передается любое значение, как правило, строка, которое надо вывести на консоль. \n\nИ в данном случае мы получим следующий вывод:</string>
    <string name="lessons04_05">При необходимости можно и не переводить курсор на следующую строку.\nВ этом случае можно использовать метод <b>System.out.print()</b>, который аналогичен <b>println</b> за тем исключением, что не осуществляет перевода на следующую строку.</string>
    <string name="lessons04_06">Консольный вывод данной программы:</string>
    <string name="lessons04_07">Но с помощью метода <b>System.out.print</b> также можно осуществить перевод каретки на следующую строку. \n\nДля этого надо использовать <b>слэш n</b>":</string>
    <string name="lessons04_08">Нередко необходимо подставлять в строку какие-нибудь данные. \n\nНапример, у нас есть два числа, и мы хотим вывести их значения на экран. \n\nВ этом случае мы можем, например, написать так:</string>
    <string name="lessons04_09">Консольный вывод программы:</string>
    <string name="lessons04_10">Но в Java есть также функция для форматированного вывода, унаследованная от языка <b>С: System.out.printf()</b>. \n\nС ее помощью мы можем переписать предыдущий пример следующим образом:</string>
    <string name="lessons04_11">В данном случае символы <b>%d</b> обозначают спецификатор, вместо которого подставляет один из аргументов. \n\nСпецификаторов и соответствующих им аргументов может быть множество. \nВ данном случае у нас только два аргумента, поэтому вместо первого <b>%d</b> подставляет значение переменной <b>x</b>, а вместо второго - значение переменной <b>y</b>. \n\nСама буква <b>d</b> означает, что данный спецификатор будет использоваться для вывода целочисленных значений.</string>
    <string name="lessons04_12">Кроме спецификатора <b>%d</b> мы можем использовать еще ряд спецификаторов для других типов данных:</string>
    <string name="lessons04_13">Например:</string>
    <string name="lessons04_14">При выводе чисел с плавающей точкой мы можем указать количество знаков после запятой, для этого используем спецификатор на <b>%.2f</b>, где <b>.2</b> указывает, что после запятой будет два знака. \n\nВ итоге мы получим следующий вывод:</string>
    <string name="lessons04_15"><u>Ввод с консоли</u></string>
    <string name="lessons04_17">Для получения ввода с консоли в классе System определен объект <b>in</b>. \n\nОднако непосредственно через объект <b>System.in</b> не очень удобно работать, поэтому, как правило, используют класс <b>Scanner</b>, который, в свою очередь использует <b>System.in</b>. \n\nНапример, напишем маленькую программу, которая осуществляет ввод чисел:</string>
    <string name="lessons04_18">Так как класс <b>Scanner</b> находится в пакете <b>java.util</b>, то мы вначале его импортируем с помощью инструкции <b>import java.util.Scanner</b>. \n\nДля создания самого объекта <b>Scanner</b> в его конструктор передается объект <b>System.in</b>. \n\nПосле этого мы можем получать вводимые значения. \n\nНапример, в данном случае вначале выводим приглашение к вводу и затем получаем вводимое число в переменную <b>num</b>. \n\nЧтобы получить введенное число, используется метод <b>in.nextInt();</b>, который возвращает введенное с клавиатуры целочисленное значение. \n\nПример работы программы:</string>
    <string name="lessons04_19">Класс <b>Scanner</b> имеет еще ряд методов, которые позволяют получить введенные пользователем значения:</string>
    <string name="lessons04_20">То есть для ввода значений каждого примитивного типа в классе <b>Scanner</b> определен свой метод. \n\nНапример, создадим программу для ввода информации о человеке:</string>
    <string name="lessons04_21">Здесь последовательно вводятся данные типов <b>String, int, float</b> и потом все введенные данные вместе выводятся на консоль. \n\nПример работы программы:</string>
    <string name="lessons04_22">Обратите внимание, что для ввода значения типа <b>float</b> (то же самое относится к типу <b>double</b>) применяется число <b>1,7</b>, где разделителем является запятая, а не <b>1.7</b>, где разделителем является точка. \n\nВ данном случае все зависит от текущей языковой локализации системы. \n\nВ моем случае русскоязычная локализация, соответственно вводить необходимо числа, где разделителем является запятая. \n\nТо же самое касается многих других локализаций, например, немецкой, французской и т.д., где применяется запятая.</string>
    <string name="less04_image01">Скриншот01_урок04</string>
    <string name="less04_image02">Скриншот02_урок04</string>
    <string name="less04_image03">Скриншот03_урок04</string>
    <string name="less04_image04">Скриншот04_урок04</string>
    <string name="less04_image05">Скриншот05_урок04</string>
    <string name="less04_image06">Скриншот06_урок04</string>
    <string name="less04_image07">Скриншот07_урок04</string>
    <string name="less04_image08">Скриншот08_урок04</string>
    <string name="less04_image09">Скриншот09_урок04</string>
    <string name="less04_image10">Скриншот10_урок04</string>
    <string name="less04_image11">Скриншот11_урок04</string>
    <string name="less04_image12">Скриншот12_урок04</string>
    <string name="less04_image13">Скриншот13_урок04</string>
    <string name="less04_image14">Скриншот14_урок04</string>
    <string name="less04_image15">Скриншот15_урок04</string>
    <string name="less04_image16">Скриншот16_урок04</string>

    <string name="ariphmetics_zagolovok"><u>Арифметические операции</u></string>
    <string name="lessons05_01">Большинство операций в <b>Java</b> аналогичны тем, которые применяются в других <b>си</b>-подобных языках. \n\nЕсть <b>унарные</b> операции (выполняются над одним операндом), <b>бинарные</b> - над двумя операндами, а также <b>тернарные</b> - выполняются над тремя операндами. \n\n<b>Операндом</b> является переменная или значение (например, число), участвующее в операции. \n\nВ арифметических операциях участвуют числа. \n\nК бинарным операциям относят следующие:</string>
    <string name="lessons05_02">При делении стоит учитывать, что если в операции участвуют два целых числа, то результат деления будет округляться до целого числа, даже если результат присваивается переменной <b>float</b> или <b>double</b>:</string>
    <string name="lessons05_03">Чтобы результат представлял число с плавающей точкой, один из операндов также должен представлять число с плавающей точкой:</string>
    <string name="lessons05_04">получение остатка от деления двух чисел:</string>
    <string name="lessons05_05">Также есть две унарные арифметические операции, которые производятся над одним числом: <b>++</b> (инкремент) и <b>--</b> (декремент). \n\nКаждая из операций имеет две разновидности: <b>префиксная</b> и <b>постфиксная</b>:</string>
    <string name="lessons05_06"><u>++ (префиксный инкремент)</u></string>
    <string name="lessons05_07">Предполагает увеличение переменной на единицу, например \n\n<b>z=++y</b> \n\n(вначале значение переменной <b>y</b> увеличивается на <b>1</b>, а затем ее значение присваивается переменной <b>z</b></string>
    <string name="lessons05_08"><u>++ (постфиксный инкремент)</u></string>
    <string name="lessons05_09">Также представляет увеличение переменной на единицу, например \n\n<b>z=y++</b> \n\n(вначале значение переменной <b>y</b> присваивается переменной <b>z</b>, а потом значение переменной y увеличивается на <b>1</b></string>
    <string name="lessons05_10"><u>-- (префиксный декремент)</u></string>
    <string name="lessons05_11">Уменьшение переменной на единицу, например \n\n<b>z=--y</b> \n\n(вначале значение переменной <b>y</b> уменьшается на <b>1</b>, а потом ее значение присваивается переменной <b>z</b></string>
    <string name="lessons05_12"><u>-- (постфиксный декремент)</u></string>
    <string name="lessons05_13"><b>z=y--</b> (сначала значение переменной <b>y</b> присваивается переменной <b>z</b>, а затем значение переменной <b>y</b> уменьшается на <b>1</b></string>
    <string name="lessons05_14"><u>Приоритет арифметических операций</u></string>
    <string name="lessons05_15">Одни операции имеют больший приоритет, чем другие, и поэтому выполняются вначале. \n\nОперации в порядке уменьшения приоритета: \n\n<b>++ (инкремент) \n\n-- (декремент) \n\n* (умножение) \n\n/ (деление) \n\n% (остаток от деления) \n\n+ (сложение) \n\n- (вычитание)</b> \n\nПриоритет операций следует учитывать при выполнении набора арифметических выражений:</string>
    <string name="lessons05_16">Вначале будет выполняться операция инкремента <b>++b</b>, которая имеет больший приоритет - она увеличит значение переменной <b>b</b> и возвратит его в качестве результата. \nЗатем выполняется умножение <b>5 * ++b</b>, и только в последнюю очередь выполняется сложение <b>a + 5 * ++b</b> \n\nСкобки позволяют переопределить порядок вычислений:</string>
    <string name="lessons05_17">Несмотря на то, что операция сложения имеет меньший приоритет, но вначале будет выполняться именно сложение, а не умножение, так как операция сложения <b>заключена в скобки</b>.</string>
    <string name="lessons05_18"><u>Ассоциативность операций</u></string>
    <string name="lessons05_19">Кроме приоритета операции отличаются таким понятием как <b>ассоциативность</b>. \n\nКогда операции имеют один и тот же приоритет, порядок вычисления определяется ассоциативностью операторов. \n\nВ зависимости от ассоциативности есть два типа операторов: \n\n<b>Левоассоциативные операторы</b>, которые выполняются слева направо \n\n<b>Правоассоциативные операторы</b>, которые выполняются справа налево \n\nТак, некоторые операции, например, операции умножения и деления, имеют один и тот же приоритет. \nКакой же тогда будет результат в выражении:</string>
    <string name="lessons05_20">Стоит нам трактовать это выражение как <b>(10 / 5) * 2</b> \nили как \n<b>10 / (5 * 2)</b> \n\nВедь в зависимости от трактовки мы получим разные результаты. \n\nВсе арифметические операторы (кроме префиксного инкремента и декремента) являются левоассоциативными, то есть выполняются слева направо. \nПоэтому выражение \n<b>10 / 5 * 2</b> необходимо трактовать как \n<b>(10 / 5) * 2</b>, то есть результатом будет <b>4</b>.</string>
    <string name="lessons05_21"><u>Операции с числами с плавающей точкой</u></string>
    <string name="lessons05_22">Следует отметить, что числа с плавающей точкой не подходят для финансовых и других вычислений, где ошибки при округлении могут быть критичными. \n\nНапример:</string>
    <string name="lessons05_23">В данном случае переменная <b>d</b> будет равна не <b>0.9</b>, как можно было бы изначально предположить, а <b>0.899999..</b>. \n\nПодобные ошибки точности возникают из-за того, что на низком уровне для представления чисел с плавающей точкой применяется двоичная система, однако для числа <b>0.1</b> не существует двоичного представления, также как и для других дробных значений. \n\nПоэтому в таких случаях обычно применяется класс <b>BigDecimal</b>, который позволяет обойти подобные ситуации.</string>
    <string name="less05_image01">Скриншот01_урок05</string>
    <string name="less05_image02">Скриншот02_урок05</string>
    <string name="less05_image03">Скриншот03_урок05</string>
    <string name="less05_image04">Скриншот04_урок05</string>
    <string name="less05_image05">Скриншот05_урок05</string>
    <string name="less05_image06">Скриншот06_урок05</string>
    <string name="less05_image07">Скриншот07_урок05</string>
    <string name="less05_image08">Скриншот08_урок05</string>
    <string name="less05_image09">Скриншот09_урок05</string>
    <string name="less05_image10">Скриншот10_урок05</string>
    <string name="less05_image11">Скриншот11_урок05</string>
    <string name="less05_image12">Скриншот12_урок05</string>
    <string name="less05_image13">Скриншот13_урок05</string>
    <string name="less05_image14">Скриншот14_урок05</string>
    <string name="less05_image15">Скриншот15_урок05</string>

    <string name="lessons06_01"><u>Поразрядные операции</u></string>
    <string name="lessons06_02">Поразрядные операции выполняются над отдельными разрядами или битами чисел. \n\nВ данных операциях в качестве операндов могут выступать только <b>целые числа</b>. \n\nКаждое число имеет определенное двоичное представление. \n\nНапример, число <b>4</b> в двоичной системе <b>100</b>, а число <b>5</b> это <b>101</b> и так далее. \n\nК примеру, возьмем следующие переменные:</string>
    <string name="lessons06_03">Тип <b>byte</b> занимает <b>1</b> байт или <b>8</b> бит, соответственно представлен <b>8</b> разрядами.\n\nПоэтому значение переменной <b>b</b> в двоичном коде будет равно <b>00000111</b>. \n\nТип <b>short</b> занимает в памяти <b>2</b> байта или <b>16</b> бит, поэтому число данного типа будет представлено <b>16</b> разрядами. \n\nИ в данном случае переменная <b>s</b> в двоичной системе будет иметь значение <b>0000 0000 0000 0111</b>. \n\nДля записи чисел со знаком в Java применяется <b>дополнительный код</b>, при котором старший разряд является знаковым. \n\nЕсли его значение равно <b>0</b>, то число положительное, и его двоичное представление не отличается от представления беззнакового числа. \n\nНапример, <b>0000 0001</b> в десятичной системе <b>1</b>. \n\nЕсли старший разряд равен <b>1</b>, то мы имеем дело с отрицательным числом. \n\nНапример, <b>1111 1111</b> в десятичной системе представляет <b>-1</b>. \n\nСоответственно, <b>1111 0011</b> представляет <b>-13</b>.</string>
    <string name="lessons06_04"><u>Логические операции</u></string>
    <string name="lessons06_05">Логические операции над числами представляют поразрядные операции. \n\nВ данном случае числа рассматриваются в двоичном представлении, \nнапример, \n<b>2</b> в двоичной системе равно <b>10</b> и имеет <b>два разряда</b>, число <b>7</b> - <b>111</b> и имеет <b>три разряда</b>. \n\n<b>&amp; (логическое умножение)</b> \n\nУмножение производится поразрядно, и если у обоих операндов значения разрядов равно <b>1</b>, то операция возвращает <b>1</b>, иначе возвращается число <b>0</b>.\n\nНапример:</string>
    <string name="lessons06_06">В первом случае у нас два числа <b>2</b> и <b>5</b>. \n\n<b>2</b> в двоичном виде представляет число <b>010</b>, а <b>5</b> это <b>101</b>. \n\nПоразрядное умножение чисел (0*1, 1*0, 0*1) дает результат <b>000</b>. \n\nВо втором случае у нас вместо двойки число <b>4</b>, у которого в первом разряде <b>1</b>, так же как и у числа <b>5</b>, поэтому здесь результатом операции \n<b>(1*1, 0*0, 0 *1) = 100</b> \nЭтобудет число 4 в десятичном формате. \n\n<b>| (логическое сложение)</b> \n\nДанная операция также производится по двоичным разрядам, но теперь возвращается единица, если хотя бы у одного числа в данном разряде имеется единица (операция логическое <b>ИЛИ</b>). \n\nНапример:</string>
    <string name="lessons06_07"><b>^ (логическое исключающее ИЛИ)</b> \n\nТакже эту операцию называют <b>XOR</b>, нередко ее применяют для простого шифрования:</string>
    <string name="lessons06_08">Здесь также производятся поразрядные операции. \n\nЕсли у нас значения текущего разряда у обоих чисел разные, то возвращается <b>1</b>, иначе возвращается <b>0</b>. \n\nНапример, результатом выражения \n<b>9^5</b> будет число <b>12</b>. \nА чтобы расшифровать число, мы применяем обратную операцию к результату. \n\n<b>~ (логическое отрицание)</b> \n\nПоразрядная операция, которая инвертирует все разряды числа: если значение разряда равно <b>1</b>, то оно становится равным <b>нулю</b>, и наоборот.</string>
    <string name="less06_image01">Скриншот01_урок06</string>
    <string name="less06_image02">Скриншот02_урок06</string>
    <string name="less06_image03">Скриншот03_урок06</string>
    <string name="less06_image04">Скриншот04_урок06</string>
    <string name="less06_image05">Скриншот05_урок06</string>

    <string name="lessons07_01"><u>Условные выражения</u></string>
    <string name="lessons07_02">Условные выражения представляют собой некоторое условие и возвращают значение типа <b>boolean</b>, то есть значение <b>true</b> (если условие истинно), или значение <b>false</b> (если условие ложно). \n\nК условным выражениям относятся операции сравнения и логические операции.</string>
    <string name="lessons07_03"><u>Операции сравнения</u></string>
    <string name="lessons07_04">В операциях сравнения сравниваются <b>два операнда</b>, и возвращается значение типа <b>boolean - true</b>, если выражение верно, и <b>false</b>, если выражение неверно. \n\n<b>==</b> \n\nсравнивает два операнда на равенство и возвращает <b>true</b> (если операнды равны) и <b>false</b> (если операнды не равны)</string>
    <string name="lessons07_05"><b>!=</b> \n\nсравнивает два операнда и возвращает <b>true</b>, если операнды НЕ равны, и <b>false</b>, если операнды равны</string>
    <string name="lessons07_06"><b>&#60;</b> (меньше чем) \n\nВозвращает <b>true</b>, если первый операнд меньше второго, иначе возвращает <b>false</b></string>
    <string name="lessons07_07"> <b>&#62;</b> (больше чем) \n\nВозвращает <b>true</b>, если первый операнд больше второго, иначе возвращает <b>false</b></string>
    <string name="lessons07_08"> <b>&#62;&#61;</b> (больше или равно) \n\nВозвращает <b>true</b>, если первый операнд больше второго или равен второму, иначе возвращает <b>false</b></string>
    <string name="lessons07_09"> <b>&#60;&#61;</b> (меньше или равно) \n\nВозвращает <b>true</b>, если первый операнд меньше второго или равен второму, иначе возвращает <b>false</b></string>
    <string name="lessons07_10"><u>Логические операции</u></string>
    <string name="lessons07_11">Также в <b>Java</b> есть логические операции, которые также представляют условие и возвращают <b>true</b> или <b>false</b> и обычно объединяют несколько операций сравнения. \n\nК логическим операциям относят следующие:</string>
    <string name="lessons07_12">Здесь у нас две пары операций <b> | </b> и <b>||</b> (а также <b>&#38;</b> и <b>&#38;&#38;</b>) выполняют похожие действия, однако же они не равнозначны. \n\nВыражение <b>c=a|b;</b> будет вычислять сначала оба значения - <b>a</b> и <b>b</b> и на их основе выводить результат. \n\nВ выражении же <b>c=a||b;</b> вначале будет вычисляться значение <b>a</b>, и если оно равно <b>true</b>, то вычисление значения <b>b</b> уже смысла не имеет, так как у нас в любом случае уже c будет равно <b>true</b>. \nЗначение <b>b</b> будет вычисляться только в том случае, если a равно <b>false</b> \n\nТо же самое касается пары операций \n<b>&#38;/&#38;&#38;</b>. \n\nВ выражении <b>c=a&#38;b;</b> будут вычисляться оба значения - <b>a и b</b>. \n\nВ выражении же <b>c=a&#38;&#38;b;</b> сначала будет вычисляться значение <b>a</b>, и если оно равно <b>false</b>, то вычисление значения <b>b</b> уже не имеет смысла, так как значение c в любом случае равно <b>false</b>. \nЗначение <b>b</b> будет вычисляться только в том случае, если <b>a</b> равно <b>true</b> \n\nТаким образом, операции <b>||</b> и <b>&#38;&#38;</b> более удобны в вычислениях, позволяя сократить время на вычисление значения выражения и тем самым повышая производительность. \n\nА операции <b>|</b> и <b>&#38;</b> больше подходят для выполнения поразрядных операций над числами.</string>
    <string name="less07_image01">Скриншот01_урок07</string>
    <string name="less07_image02">Скриншот02_урок07</string>
    <string name="less07_image03">Скриншот03_урок07</string>
    <string name="less07_image04">Скриншот04_урок07</string>
    <string name="less07_image05">Скриншот05_урок07</string>
    <string name="less07_image06">Скриншот06_урок07</string>

    <string name="lessons08_01"><u>Операции присваивания</u></string>
    <string name="lessons08_02">В этом уроке мы рассмотрим <b>операции присваивания</b>, которые в основном представляют комбинацию простого присваивания с другими операциями:</string>
    <string name="less08_image01">Скриншот01_урок08</string>
    <string name="less08_image02">Скриншот02_урок08</string>
    <string name="less08_image03">Скриншот03_урок08</string>
    <string name="less08_image04">Скриншот04_урок08</string>
    <string name="less08_image05">Скриншот05_урок08</string>

    <string name="lessons09_01"><u>Преобразования базовых типов данных</u></string>
    <string name="lessons09_02">Каждый базовый тип данных занимает определенное количество байт памяти. \nЭто накладывает ограничение на операции, в которые вовлечены различные типы данных. \n\nРассмотрим следующий пример:</string>
    <string name="lessons09_03">В данном коде мы столкнемся с ошибкой. Хотя и тип <b>byte</b>, и тип <b>int</b> представляют целые числа. \n\nБолее того, значение переменной <b>a</b>, которое присваивается переменной типа <b>byte</b>, вполне укладывается в диапазон значений для типа <b>byte</b> \n(от -128 до 127). \n\nТем не менее мы сталкиваемся с ошибкой на этапе компиляции. \n\nПоскольку в данном случае мы пытаемся присвоить некоторые данные, которые занимают <b>4 байта</b>, переменной, которая занимает всего <b>1 байт</b>. \n\nТем не менее в программе может потребоваться, чтобы подобное преобразование было выполнено. \n\nВ этом случае необходимо использовать операцию преобразования типов <b>(операция ())</b>:</string>
    <string name="lessons09_04">Операция преобразования типов предполагает указание в скобках того типа, к которому надо преобразовать значение. \n\nНапример, в случае операции <b>(byte) a</b>, идет преобразование данных типа <b>int</b> в тип <b>byte</b>. \n\nВ итоге мы получим значение типа <b>byte</b>.</string>
    <string name="lessons09_05"><u>Явные и неявные преобразования</u></string>
    <string name="lessons09_06">Когда в одной операции вовлечены данные разных типов, не всегда необходимо использовать операцию преобразования типов. \n\nНекоторые виды преобразований выполняются неявно, автоматически.</string>
    <string name="lessons09_07"><u>Автоматические преобразования</u></string>
    <string name="lessons09_08">Стрелками на рисунке показано, какие преобразования типов могут выполняться автоматически. \n\nПунктирными стрелками показаны автоматические преобразования с потерей точности. \n\nАвтоматически без каких-либо проблем производятся расширяющие преобразования (widening) - они расширяют представление объекта в памяти. \n\nНапример:</string>
    <string name="lessons09_09">В данном случае значение типа <b>byte</b>, которое занимает в памяти <b>1 байт</b>, расширяется до типа <b>int</b>, которое занимает <b>4 байта</b>. \n\nРасширяющие автоматические преобразования представлены следующими цепочками:</string>
    <string name="lessons09_10"><u>Автоматические преобразования с потерей точности</u></string>
    <string name="lessons09_11">Некоторые преобразования могут производиться автоматически между типами данных одинаковой разрядности или даже от типа данных с большей разрядностью к типа с меньшей разрядностью. \n\nЭто следующие цепочки преобразований: \n<b>int -> float,</b> \n<b>long -> float</b>\n<b>long -> double</b>. \n\nОни производятся без ошибок, но при преобразовании мы можем столкнуться с потерей информации. \n\nНапример:</string>
    <string name="lessons09_12"><u>Явные преобразования</u></string>
    <string name="lessons09_13">Во всех остальных преобразованиях примитивных типов явным образом применяется операция преобразования типов. \n\nОбычно это сужающие преобразования (narrowing) от типа с большей разрядностью к типу с меньшей разрядностью:</string>
    <string name="lessons09_14"><u>Потеря данных при преобразовании</u></string>
    <string name="lessons09_15">При применении явных преобразований мы можем столкнуться с потерей данных. \n\nНапример, в следующем коде у нас не возникнет никаких проблем:</string>
    <string name="lessons09_16">Число <b>5</b> вполне укладывается в диапазон значений типа <b>byte</b>, поэтому после преобразования переменная <b>b</b> будет равна <b>5</b>. \n\nНо что будет в следующем случае:</string>
    <string name="lessons09_17">Результатом будет число <b>2</b>. \nВ данном случае число <b>258</b> вне диапазона для типа <b>byte</b> (от -128 до 127), поэтому произойдет усечение значения. \n\nПочему результатом будет именно число 2? \n\nЧисло <b>a</b>, которое равно <b>258</b>, в двоичном системе будет равно \n00000000 00000000 00000001 00000010. \n\nЗначения типа <b>byte</b> занимают в памяти только <b>8 бит</b>. \nПоэтому двоичное представление числа <b>int</b> усекается до <b>8</b> правых разрядов, то есть <b>00000010</b>, что в десятичной системе дает число <b>2</b>.</string>
    <string name="lessons09_18"><u>Усечение рациональных чисел до целых</u></string>
    <string name="lessons09_19">При преобразовании значений с плавающей точкой к целочисленным значениям, происходит усечение дробной части:</string>
    <string name="lessons09_20">Здесь значение числа <b>b</b> будет равно <b>56</b>, несмотря на то, что число <b>57</b> было бы ближе к <b>56.9898</b>. \n\nЧтобы избежать подобных казусов, надо применять функцию округления, которая есть в математической библиотеке Java:</string>
    <string name="lessons09_21"><u>Преобразования при операциях</u></string>
    <string name="lessons09_22">Нередки ситуации, когда приходится применять различные операции, например, сложение и произведение, над значениями разных типов. \n\nЗдесь также действуют некоторые правила: \n\n-если один из операндов операции относится к типу <b>double</b>, то и второй операнд преобразуется к типу <b>double</b> \n\n-если предыдущее условие не соблюдено, а один из операндов операции относится к типу <b>float</b>, то и второй операнд преобразуется к типу <b>float</b> \n\n-если предыдущие условия не соблюдены, один из операндов операции относится к типу <b>long</b>, то и второй операнд преобразуется к типу <b>long</b> \n\n-иначе все операнды операции преобразуются к типу <b>int</b> \n\nПримеры преобразований:</string>
    <string name="lessons09_23">Так как в операции участвует значение типа <b>double</b>, то и другое значение приводится к типу <b>double</b> и сумма двух значений <b>a+b</b> будет представлять тип <b>double</b></string>
    <string name="lessons09_24">Две переменных типа <b>byte</b> и <b>short</b> (не <b>double, float или long</b>), поэтому при сложении они преобразуются к типу <b>int</b>, и их сумма <b>a+b</b> представляет значение типа <b>int</b>. \n\nПоэтому если затем мы присваиваем эту сумму переменной типа <b>byte</b>, то нам опять надо сделать преобразование типов к <b>byte</b>. \n\nЕсли в операциях участвуют данные типа <b>char</b>, то они преобразуются в <b>int</b>:</string>
    <string name="less09_image01">Скриншот01_урок09</string>
    <string name="less09_image02">Скриншот02_урок09</string>
    <string name="less09_image03">Скриншот03_урок09</string>
    <string name="less09_image04">Скриншот04_урок09</string>
    <string name="less09_image05">Скриншот05_урок09</string>
    <string name="less09_image06">Скриншот06_урок09</string>
    <string name="less09_image07">Скриншот07_урок09</string>
    <string name="less09_image08">Скриншот08_урок09</string>
    <string name="less09_image09">Скриншот09_урок09</string>
    <string name="less09_image10">Скриншот10_урок09</string>
    <string name="less09_image11">Скриншот11_урок09</string>
    <string name="less09_image12">Скриншот12_урок09</string>
    <string name="less09_image13">Скриншот13_урок09</string>
    <string name="less09_image14">Скриншот14_урок09</string>

    <string name="lessons10_01"><u>Условные конструкции</u></string>
    <string name="lessons10_02">Одним из фундаментальных элементов многих языков программирования являются <b>условные конструкции</b>. \nДанные конструкции позволяют направить работу программы по одному из путей в зависимости от определенных условий. \n\nВ языке Java используются следующие условные конструкции: \n<b>if..else\nswitch..case</b></string>
    <string name="lessons10_03"><u>Конструкция if/else</u></string>
    <string name="lessons10_04">Выражение <b>if/else</b> проверяет истинность некоторого условия и в зависимости от результатов проверки выполняет определенный код:</string>
    <string name="lessons10_05">После ключевого слова <b>if</b> ставится условие. \nИ если это условие выполняется, то срабатывает код, который помещен в далее в блоке <b>if</b> после фигурных скобок. \n\nВ качестве условий выступает операция сравнения двух чисел. \n\nТак как, в данном случае первое число больше второго, то выражение <b>num1 > num2</b> истинно и возвращает значение <b>true</b>. \nСледовательно, управление переходит в блок кода после фигурных скобок и начинает выполнять содержащиеся там инструкции, а конкретно метод <b>System.out.println(&#34;Первое число больше второго&#34;);</b>\n\nЕсли бы первое число оказалось бы меньше второго или равно ему, то инструкции в блоке <b>if</b> не выполнялись бы. \nНо что, если мы захотим, чтобы при несоблюдении условия также выполнялись какие-либо действия? \n\nВ этом случае мы можем добавить блок <b>else</b>:</string>
    <string name="lessons10_06">Но при сравнении чисел мы можем насчитать три состояния: первое число больше второго, первое число меньше второго и числа равны. \n\nС помощью выражения <b>else if</b>, мы можем обрабатывать дополнительные условия:</string>
    <string name="lessons10_07">Также мы можем соединить сразу несколько условий, используя логические операторы:</string>
    <string name="lessons10_08">Здесь блок <b>if</b> будет выполняться, если <b>num1 > num2</b> равно <b>true</b> и одновременно <b>num1>7</b> равно <b>true</b></string>
    <string name="lessons10_09"><u>Конструкция switch</u></string>
    <string name="lessons10_10">Конструкция <b>switch/case</b> аналогична конструкции <b>if/else</b>, так как позволяет обработать сразу несколько условий:</string>
    <string name="lessons10_11">После ключевого слова <b>switch</b> в скобках идет сравниваемое выражение. \n\nЗначение этого выражения последовательно сравнивается со значениями, помещенными после операторов <b>сase</b>. \nИ если совпадение найдено, то будет выполняет соответствующий блок <b>сase</b>. \nВ конце блока <b>сase</b> ставится оператор <b>break</b>, чтобы избежать выполнения других блоков. \n\nНапример, если бы убрали оператор <b>break</b> в следующем случае:</string>
    <string name="lessons10_12">то выполнился бы блок <b>case 8</b>, (поскольку переменная <b>num равна 8</b>). \nНо так как в этом блоке оператор <b>break</b> отсутствует, то начал бы выполняться блок <b>case 9</b>. \n\nЕсли мы хотим также обработать ситуацию, когда совпадения не будет найдено, то можно добавить блок <b>default</b>, как в примере выше. \n\nХотя блок <b>default</b> необязателен. \n\nТакже мы можем определить одно действие сразу для нескольких блоков <b>case</b> подряд:</string>
    <string name="lessons10_13"><u>Тернарная операция</u></string>
    <string name="lessons10_14">Тернарную операция имеет следующий синтаксис: \n[первый операнд - условие] ? \n[второй операнд] : \n[третий операнд]. \n\nТаким образом, в этой операции участвуют сразу три операнда. \nВ зависимости от условия тернарная операция возвращает второй или третий операнд: если условие равно <b>true</b>, то возвращается второй операнд; если условие равно <b>false</b>, то третий. \n\nНапример:</string>
    <string name="lessons10_15">Здесь результатом тернарной операции является переменная <b>z</b>. \n\nСначала проверяется условие <b>x&#60;y</b>. \nИ если оно соблюдается, то <b>z</b> будет равно второму операнду - \n(x+y), \nиначе <b>z</b> будет равно третьему операнду</string>
    <string name="less10_image01">Скриншот01_урок10</string>
    <string name="less10_image02">Скриншот02_урок10</string>
    <string name="less10_image03">Скриншот03_урок10</string>
    <string name="less10_image04">Скриншот04_урок10</string>
    <string name="less10_image05">Скриншот05_урок10</string>
    <string name="less10_image06">Скриншот06_урок10</string>
    <string name="less10_image07">Скриншот07_урок10</string>
    <string name="less10_image08">Скриншот08_урок10</string>

    <string name="lessons11_01"><u>Циклы</u></string>
    <string name="lessons11_02">Еще одним видом управляющих конструкций являются <b>циклы</b>. \n\nЦиклы позволяют в зависимости от определенных условий выполнять определенное действие множество раз. \n\nВ языке Java есть следующие виды циклов: \n<b>for, while, do while</b></string>
    <string name="lessons11_03"><u>Цикл for</u></string>
    <string name="lessons11_04">Цикл <b>for</b> имеет следующее формальное определение:</string>
    <string name="lessons11_05">Рассмотрим стандартный цикл <b>for</b>:</string>
    <string name="lessons11_06">Первая часть объявления цикла - <b>\nint i = 1</b> создает и инициализирует счетчик <b>i</b>. \nСчетчик необязательно должен представлять тип <b>int</b>. \n\nЭто может быть и любой другой числовой тип, например, <b>float</b>. \n\nПеред выполнением цикла значение счетчика будет равно <b>1</b>. \nВ данном случае это то же самое, что и объявление переменной. \nВторая часть - условие, при котором будет выполняться цикл. \n\nВ данном случае цикл будет выполняться, пока <b>i</b> не достигнет <b>9</b>. \nИ третья часть - приращение счетчика на единицу. \n\nОпять же нам необязательно увеличивать на единицу. \nМожно уменьшать: <b>i--</b>. \n\nВ итоге блок цикла сработает 8 раз, пока значение <b>i</b> не станет равным <b>9</b>. И каждый раз это значение будет увеличиваться на 1. \n\nНам необязательно указывать все условия при объявлении цикла. \n\nНапример, мы можем написать так:</string>
    <string name="lessons11_07">Определение цикла осталось тем же, только теперь блоки в определении у нас пустые: \n<b>for (; ;)</b>. \n\nТеперь нет инициализированной переменной-счетчика, нет условия, поэтому цикл будет работать вечно - бесконечный цикл. \n\nЛибо можно опустить ряд блоков:</string>
    <string name="lessons11_08">Этот пример эквивалентен первому примеру: у нас также есть счетчик, только создан он вне цикла. \nУ нас есть условие выполнения цикла. И есть приращение счетчика уже в самом блоке <b>for</b>. \n\nЦикл <b>for</b> может определять сразу несколько переменных и управлять ими:</string>
    <string name="lessons11_09"><u>Цикл do</u></string>
    <string name="lessons11_10">Цикл <b>do</b> сначала выполняет код цикла, а потом проверяет условие в инструкции <b>while</b>. \nИ пока это условие истинно, цикл повторяется. \n\nНапример:</string>
    <string name="lessons11_11">В данном случае код цикла сработает <b>7 раз</b>, пока <b>j</b> не окажется равным нулю. \nВажно отметить, что <b>цикл do</b> гарантирует хотя бы однократное выполнение действий, даже если условие в инструкции <b>while</b> не будет истинно. \n\nТак, мы можем написать:</string>
    <string name="lessons11_12">Хотя переменная <b>j</b> изначально меньше <b>0</b>, цикл все равно один раз выполнится.</string>
    <string name="lessons11_13"><u>Цикл while</u></string>
    <string name="lessons11_14">Цикл <b>while</b> сразу проверяет истинность некоторого условия, и если условие истинно, то код цикла выполняется:</string>
    <string name="lessons11_15"><u>Операторы continue и break</u></string>
    <string name="lessons11_16">Оператор <b>break</b> позволяет выйти из цикла в любой его момент, даже если цикл не закончил свою работу: \n\nНапример:</string>
    <string name="lessons11_17">Когда счетчик станет равным <b>5</b>, сработает оператор <b>break</b>, и цикл завершится. \n\nТеперь сделаем так, чтобы если число равно <b>5</b>, цикл не завершался, а просто переходил к следующей итерации. \nДля этого используем оператор <b>continue</b>:</string>
    <string name="lessons11_18">В этом случае, когда выполнение цикла дойдет до числа <b>5</b>, программа просто пропустит это число и перейдет к следующему.</string>
    <string name="less11_image01">Скриншот01_урок11</string>
    <string name="less11_image02">Скриншот02_урок11</string>
    <string name="less11_image03">Скриншот03_урок11</string>
    <string name="less11_image04">Скриншот04_урок11</string>
    <string name="less11_image05">Скриншот05_урок11</string>
    <string name="less11_image06">Скриншот06_урок11</string>
    <string name="less11_image07">Скриншот07_урок11</string>
    <string name="less11_image08">Скриншот08_урок11</string>
    <string name="less11_image09">Скриншот09_урок11</string>
    <string name="less11_image10">Скриншот10_урок11</string>

    <string name="lessons12_01"><u>Массивы</u></string>
    <string name="lessons12_02"><b>Массив</b> представляет набор однотипных значений. \n\nОбъявление массива похоже на объявление обычной переменной, которая хранит одиночное значение, причем есть два способа объявления массива:</string>
    <string name="lessons12_03">Например, определим массив чисел:</string>
    <string name="lessons12_04">После объявления массива мы можем инициализовать его:</string>
    <string name="lessons12_05">Создание массива производится с помощью следующей конструкции: \n\n<b>new тип_данных[количество_элементов]</b>, \n\nгде new - ключевое слово, выделяющее память для указанного в скобках количества элементов. \n\nНапример, <b>nums = new int[4];</b> - в этом выражении создается массив из четырех элементов <b>int</b>, и каждый элемент будет иметь значение по умолчанию - число 0. \n\nТакже можно сразу при объявлении массива инициализировать его:</string>
    <string name="lessons12_06">При подобной инициализации все элементы массива имеют значение по умолчанию. \n\nДля числовых типов (в том числе для типа <b>char</b>) это число 0, для типа <b>boolean</b> это значение <b>false</b>, а для остальных объектов это значение <b>null</b>. \n\nНапример, для типа <b>int</b> значением по умолчанию является число 0, поэтому выше определенный массив <b>nums</b> будет состоять из четырех нулей. \n\nОднако также можно задать конкретные значения для элементов массива при его создании:</string>
    <string name="lessons12_07">Стоит отметить, что в этом случае в квадратных скобках не указывается размер массива, так как он вычисляется по количеству элементов в фигурных скобках. \n\nПосле создания массива мы можем обратиться к любому его элементу по индексу, который передается в квадратных скобках после названия переменной массива:</string>
    <string name="lessons12_08">Индексация элементов массива начинается с 0, поэтому в данном случае, чтобы обратиться к четвертому элементу в массиве, нам надо использовать выражение <b>nums[3]</b>. \n\nИ так как у нас массив определен только для 4 элементов, то мы не можем обратиться, например, к шестому элементу: \n<b>nums[5] = 5;</b>. \n\nЕсли мы так попытаемся сделать, то мы получим ошибку.</string>
    <string name="lessons12_09"><u>Длина массива</u></string>
    <string name="lessons12_10">Важнейшее свойство, которым обладают массивы, является свойство <b>length</b>, возвращающее длину массива, то есть количество его элементов:</string>
    <string name="lessons12_11">Нередко бывает неизвестным последний индекс, и чтобы получить последний элемент массива, мы можем использовать это свойство:</string>
    <string name="lessons12_12"><u>Многомерные массивы</u></string>
    <string name="lessons12_13">Ранее мы рассматривали одномерные массивы, которые можно представить как цепочку или строку однотипных значений. \n\nНо кроме одномерных массивов также бывают и многомерными. \n\nНаиболее известный многомерный массив - таблица, представляющая двухмерный массив:</string>
    <string name="lessons12_14">Визуально оба массива можно представить следующим образом:</string>
    <string name="lessons12_15">Поскольку массив <b>nums2</b> двухмерный, он представляет собой простую таблицу. \n\nЕго также можно было создать следующим образом: <b>int[][] nums2 = new int[2][3];</b>. \n\nКоличество квадратных скобок указывает на размерность массива. \nА числа в скобках - на количество строк и столбцов. \n\nИ также, используя индексы, мы можем использовать элементы массива в программе:</string>
    <string name="lessons12_16">Объявление трехмерного массива могло бы выглядеть так:</string>
    <string name="lessons12_17"><u>Зубчатый массив</u></string>
    <string name="lessons12_18">Многомерные массивы могут быть также представлены как зубчатые массивы. \n\nВ вышеприведенном примере двухмерный массив имел 3 строчки и три столбца, поэтому у нас получалась ровная таблица. \n\nНо мы можем каждому элементу в двухмерном массиве присвоить отдельный массив с различным количеством элементов:</string>
    <string name="lessons12_19"><u>foreach</u></string>
    <string name="lessons12_20">Специальная версия цикла <b>for</b> предназначена для перебора элементов в наборах элементов, например, в массивах и коллекциях. \n\nОна аналогична действию цикла <b>foreach</b> , который имеется в других языках программирования. \n\nФормальное ее объявление:</string>
    <string name="lessons12_21">Например:</string>
    <string name="lessons12_22">В качестве контейнера в данном случае выступает массив данных типа <b>int</b>. \n\nЗатем объявляется переменная с типом <b>int</b> \n\nТо же самое можно было бы сделать и с помощью обычной версии <b>for:</b></string>
    <string name="lessons12_23">В то же время эта версия цикла <b>for</b> более гибкая по сравнению \n<b>for (int i : array)</b>. \n\nВ частности, в этой версии мы можем изменять элементы:</string>
    <string name="lessons12_24"><u>Перебор многомерных массивов в цикле</u></string>
    <string name="lessons12_25">Сначала создается цикл для перебора по строкам, а затем внутри первого цикла создается внутренний цикл для перебора по столбцам конкретной строки. \n\nПодобным образом можно перебрать и трехмерные массивы и наборы с большим количеством размерностей.</string>
    <string name="less12_image01">Скриншот01_урок12</string>
    <string name="less12_image02">Скриншот02_урок12</string>
    <string name="less12_image03">Скриншот03_урок12</string>
    <string name="less12_image04">Скриншот04_урок12</string>
    <string name="less12_image05">Скриншот05_урок12</string>
    <string name="less12_image06">Скриншот06_урок12</string>
    <string name="less12_image07">Скриншот07_урок12</string>
    <string name="less12_image08">Скриншот08_урок12</string>
    <string name="less12_image09">Скриншот09_урок12</string>
    <string name="less12_image10">Скриншот10_урок12</string>
    <string name="less12_image11">Скриншот11_урок12</string>
    <string name="less12_image12">Скриншот12_урок12</string>
    <string name="less12_image13">Скриншот13_урок12</string>
    <string name="less12_image14">Скриншот14_урок12</string>
    <string name="less12_image15">Скриншот15_урок12</string>
    <string name="less12_image16">Скриншот16_урок12</string>
    <string name="less12_image17">Скриншот17_урок12</string>
    <string name="less12_image18">Скриншот18_урок12</string>
    <string name="less12_image19">Скриншот19_урок12</string>

    <string name="lessons13_01"><u>Методы</u></string>
    <string name="lessons13_02">Если переменные и константы хранят некоторые значения, то методы содержат собой набор операторов, которые выполняют определенные действия. \n\nОбщее определение методов выглядит следующим образом:</string>
    <string name="lessons13_03">Модификаторы и параметры необязательны. \n\nПо умолчанию главный класс любой программы на <b>Java</b> содержит метод <b>main</b>, который служит точкой входа в программу:</string>
    <string name="lessons13_04">Ключевые слова <b>public</b> и <b>static</b> являются модификаторами. \n\nДалее идет тип возвращаемого значения. \n\nКлючевое слово <b>void</b> указывает на то, что метод ничего не возвращает. \n\nЗатем идут название метода - <b>main</b> и в скобках параметры метода - \n<b>String[] args</b>. \n\nИ в фигурные скобки заключено тело метода - все действия, которые он выполняет. \n\nСоздадим еще несколько методов:</string>
    <string name="lessons13_05">Здесь определены два дополнительных метода: <b>hello</b> и <b>welcome</b>, каждый из которых выводит некоторую строку на консоль. \n\nМетоды определяются внутри класса - в данном случае внутри класса <b>Program</b>, в котором определен метод <b>main</b>. \n\nНо если мы скомпилируем и запустим данную программу, то мы ничего не увидим на консоли. \n\nВ примере выше мы определили два метода, но мы их нигде не вызываем. \n\nПо умолчанию в программе Java выполняется только метод <b>main</b> и все его содержимое. \nПоэтому, если мы хотим, чтобы другие методы тоже выполнялись, их надо вызвать в методе <b>main</b>. \n\nВызов метода осуществляется в форме:</string>
    <string name="lessons13_06">После имени метода указываются <b>скобки</b>, в которых перечисляются аргументы - значения для параметров метода. \n\nНапример, определим и выполним несколько методов:</string>
    <string name="lessons13_07">В методе <b>main</b> вызывается один раз метод <b>hello</b> и два раза метод <b>welcome</b>. \n\nВ этом и заключается одно из преимуществ методов: \nмы можем вынести некоторые общие действия в отдельный метод и затем вызывать многократно их в различных местах программы. \n\nПоскольку оба метода не имеют никаких параметров, то после их названия при вызове ставятся пустые скобки. \n\nТакже следует отметить, что чтобы вызвать в методе <b>main</b> другие методы, которые определены в одном классе с методом <b>main</b>, они должны иметь модификатор <b>static</b>. \n\nВ итоге после компиляции и выполнения программы мы увидим на консоли:</string>

    <string name="lessons14_01"><u>Параметры методов</u></string>
    <string name="lessons14_02">С помощью параметров мы можем передать в методы различные данные, которые будут использоваться для вычислений. \n\nНапример:</string>
    <string name="lessons14_03">Данная функция принимает два параметра - два числа, складывает их и выводит их сумму на консоль. \n\nА при вызове этого метода в программе нам необходимо передать на место параметров значения, которые соответствуют типу параметра:</string>
    <string name="lessons14_04">Поскольку метод <b>sum</b> принимает два значения типа <b>int</b>, то на место параметров надо передать два значения типа <b>int</b>. \n\nЭто могут быть и числовые литералы, и переменные типов данных, которые представляют тип <b>int</b> или могут быть автоматически преобразованы в тип <b>int</b>. \n\nЗначения, которые передаются на место параметров, еще называются аргументами. \n\nЗначения передаются параметрам по позиции, то есть первый аргумент первому параметру, второй аргумент - второму параметру и так далее. \n\nРассмотрим другой пример:</string>
    <string name="lessons14_05">Метод <b>display</b> принимает два параметра. \n\nПервый параметр представляет тип <b>String</b>, а второй - тип <b>int</b>. \n\nПоэтому при вызове метода вначале в него надо передать строку, а затем число.</string>
    <string name="lessons14_06"><u>Параметры переменной длины</u></string>
    <string name="lessons14_07">Метод может принимать параметры переменной длины одного типа. \n\nНапример, нам надо передать в метод набор числел и вычислить их сумму, но мы точно не знаем, сколько именно чисел будет передано - 3, 4, 5 или больше. \n\nПараметры переменной длины позволяют решить эту задачу:</string>
    <string name="lessons14_08">Троеточие перед названием параметра <b>int nums</b> указывает на то, что он будет необязательным и будет представлять массив. \n\nМы можем передать в метод <b>sum</b> одно число, несколько чисел, а можем вообще не передавать никаких параметров. \n\nПричем, если мы хотим передать несколько параметров, то необязательный параметр должен указываться в конце:</string>

    <string name="lessons15_01"><u>Оператор return</u></string>
    <string name="lessons15_02">Методы могут возвращать некоторое значение. Для этого применяется оператор <b>return</b>.</string>
    <string name="lessons15_03">После оператора <b>return</b> указывается возвращаемое значение, которое является результатом метода. \n\nЭто может быть литеральное значение, значение переменной или какого-то сложного выражения. \n\nНапример:</string>
    <string name="lessons15_04">В методе в качестве типа возвращаемого значения вместо <b>void</b> используется любой другой тип. \n\nВ данном случае метод <b>sum</b> возвращает значение типа <b>int</b>, поэтому этот тип указывается перед названием метода. \n\nПричем если в качестве возвращаемого типа для метода определен любой другой, отличный от <b>void</b>, то метод обязательно должен использовать оператор <b>return</b> для возвращения значения. \n\nПри этом возвращаемое значение всегда должно иметь тот же тип, что значится в определении функции. \n\nИ если функция возвращает значение типа <b>int</b>, то после оператора <b>return</b> стоит целочисленное значение, которое является объектом типа <b>int</b>. \n\nКак в данном случае это сумма значений параметров метода. \n\nМетод может использовать несколько вызовов оператора <b>return</b> для возваращения разных значений в зависимости от некоторых условий:</string>
    <string name="lessons15_05">Здесь метод <b>daytime</b> возвращает значение типа <b>String</b>, то есть строку, и в зависимости от значения параметра <b>hour</b> возвращаемая строка будет различаться.</string>
    <string name="lessons15_06">Вывод на экран будет следующим: \n\n<b>Good morning \nGood after noon \nGood evening \nGood night</b></string>
    <string name="lessons15_07"><u>Выход из метода</u></string>
    <string name="lessons15_08">Оператор <b>return</b> применяется для возвращаения значения из метода, но и для выхода из метода. \n\nВ подобном качестве оператор <b>return</b> применяется в методах, которые ничего не возвращают, то есть имеют тип <b>void</b>:</string>
    <string name="lessons15_09">Если переданное в метод <b>datetime</b> значение больше 24 или меньше 0, то просто выходим из метода.\n\nВозвращаемое значение после <b>return</b> указывать в этом случае не нужно.</string>

    <string name="lessons16_01"><u>Перегрузка методов</u></string>
    <string name="lessons16_02">В программе мы можем использовать методы с одним и тем же именем, но с разными типами и/или количеством параметров. \n\nТакой механизм называется <b>перегрузкой методов</b> \n(method overloading). \n\nНапример:</string>
    <string name="lessons16_03">Здесь определено три варианта или три перегрузки метода <b>sum()</b>, но при его вызове в зависимости от типа и количества передаваемых параметров система выберет именно ту версию, которая наиболее подходит. \n\nСтоит отметить, что на перегрузку методов влияют количество и типы параметров. \n\nОднако различие в типе возвращаемого значения для перегрузки не имеют никакого значения. \n\nНапример, в следующем случае методы различаются по типу возвращаемого значения:</string>
    <string name="lessons16_04">Однако перегрузкой это не будет считаться. \n\nБолее того такая программа некорректна и попросту не скомилируется, так как метод с одним и тем же количеством и типом параметров определен несколько раз.</string>

    <string name="lessons17_01"><u>Рекурсивные функции</u></string>
    <string name="lessons17_02">Отдельно рассмотрим рекурсивные функции. \n\nГлавное отличие рекурсивных функций от обычных методов состоит в том, что они рекурсивная функция может вызывать саму себя. \n\nНапример, рассмотрим функцию, которая вычисляет факториал числа:</string>
    <string name="lessons17_03">Вначале проверяется условие: если вводимое число не равно 1, то мы умножаем данное число на результат этой же функции, в которую в качестве параметра передается число <b>x-1</b>. \n\nТо есть происходит рекурсивный спуск. \n\nИ так дальше, пока не дойдем того момента, когда значение параметра не будет равно единице. \n\nРекурсивная функция обязательно должна иметь некоторый базовый вариант, который использует оператор <b>return</b> и который помещается в начале функции. \n\nВ случае с факториалом это \n<b>if (x == 0) return 1;</b>. \n\nИ все рекурсивные вызовы должны обращаться к подфункциям, которые в конечном счете сходятся к базовому варианту. \n\nТак, при передаче в функцию положительного числа при дальнейших рекурсивных вызовах подфункций в них будет передаваться каждый раз число, меньшее на единицу. \n\nИ в конце концов мы дойдем до ситуации, когда число будет равно 0, и будет использован базовый вариант. \n\nХотя в данном случае нужно отметить, что для определения факториала есть более оптимальные решения на основе циклов:</string>
    <string name="lessons17_04">Еще одним распространенным примером рекурсивной функции служит функция, вычисляющая числа Фибоначчи. \n\nВ теории <b>n-й</b> член последовательности Фибоначчи определяется по формуле: \n<b>f(n)=f(n-1) + f(n-2)</b>, \nпричем \n<b>f(0)=0, а f(1)=1</b>.</string>

    <string name="lessons18_01"><u>Введение в обработку исключений</u></string>
    <string name="lessons18_02">Нередко в процессе выполнения программы могут возникать ошибки, при том необязательно по вине разработчика. \n\nНекоторые из них трудно предусмотреть или предвидеть, а иногда и вовсе невозможно. \n\nТак, например, может неожиданно оборваться сетевое подключение при передаче файла. \nПодобные ситуации называются исключениями.</string>
    <string name="lessons18_03">В языке <b>Java</b> предусмотрены специальные средства для обработки подобных ситуаций. \n\nОдним из таких средств является конструкция <b>try..catch..finally</b>. \n\nПри возникновении исключения в блоке <b>try</b> управление переходит в блок <b>catch</b>, который может обработать данное исключение. \n\nЕсли такого блока не найдено, то пользователю отображается сообщение о необработанном исключении, а дальнейшее выполнение программы останавливается. \n\nИ чтобы подобной остановки не произошло, и надо использовать блок <b>try..catch</b>. \n\nНапример:</string>
    <string name="lessons18_04">Так как у нас массив <b>numbers</b> может содержать только 3 элемента, то при выполнении инструкции \n<b>numbers[4]=45</b> консоль отобразит исключение, и выполнение программы будет завершено. \n\nТеперь попробуем обработать это исключение:</string>
    <string name="lessons18_05">При использовании блока <b>try catch</b> вначале выполняются все инструкции между операторами <b>try</b> и <b>catch</b>. \n\nЕсли в блоке <b>try</b> вдруг возникает исключение, то обычный порядок выполнения останавливается и переходит к инструкции <b>сatch</b>. \n\nПоэтому когда выполнение программы дойдет до строки \n<b>numbers[4]=45;</b> \nпрограмма остановится и перейдет к блоку <b>catch</b> \n\nВыражение <b>catch</b> имеет следующий синтаксис: \n\n-<b>catch</b> (тип_исключения имя_переменной). \n\nВ данном случае объявляется переменная <b>ex</b>, которая имеет тип <b>Exception</b>. \n\nНо если возникшее исключение не является исключением типа, указанного в инструкции <b>сatch</b>, то оно не обрабатывается, а программа просто зависает или выбрасывает сообщение об ошибке.</string>
    <string name="lessons18_06">Но так как тип <b>Exception</b> является базовым классом для всех исключений, то выражение \n<b>catch (Exception ex)</b> \nбудет обрабатывать практически все исключения. \n\nОбработка же исключения в данном случае сводится к выводу на консоль стека трассировки ошибки с помощью метода \n<b>printStackTrace()</b>, определенного в классе <b>Exception</b>. \n\nПосле завершения выполнения блока <b>catch</b> программа продолжает свою работу, выполняя все остальные инструкции после блока <b>catch</b>. \n\nКонструкция <b>try..catch</b> также может иметь блок <b>finally</b>. \n\nОднако этот блок необязательный, и его можно при обработке исключений опускать.\n\nБлок <b>finally</b> выполняется в любом случае, возникло ли исключение в блоке <b>try</b> или нет:</string>
    <string name="lessons18_07"><u>Обработка нескольких исключений</u></string>
    <string name="lessons18_08">В <b>Java</b> имеется множество различных типов исключений, и мы можем разграничить их обработку, включив дополнительные блоки <b>catch</b>:</string>
    <string name="lessons18_09">Если у нас возникает исключение определенного типа, то оно переходит к соответствующему блоку <b>catch</b>.</string>
    <string name="lessons18_10"><u>Оператор throw</u></string>
    <string name="lessons18_11">Чтобы сообщить о выполнении исключительных ситуаций в программе, можно использовать оператор <b>throw</b>. \n\nТо есть с помощью этого оператора мы сами можем создать исключение и вызвать его в процессе выполнения. \n\nНапример, в нашей программе происходит ввод числа, и мы хотим, чтобы, если число больше 30, то возникало исключение:</string>
    <string name="lessons18_12">Здесь для создания объекта исключения используется конструктор класса <b>Exception</b>, в который передается сообщение об исключении. \nИ если число х окажется больше 29, то будет выброшено исключение и управление перейдет к блоку <b>catch</b>. \n\nВ блоке <b>catch</b> мы можем получить сообщение об исключении с помощью метода <b>getMessage()</b>.</string>

    <string name="lessonsOop01_01"><u>Классы и объекты</u></string>
    <string name="lessonsOop01_02"><b>Java</b> является объектно-ориентированным языком, поэтому такие понятия как класс и объект играют в нем ключевую роль.\n\nЛюбую программу на <b>Java</b> можно представить как набор взаимодействующих между собой объектов. \nШаблоном или описанием объекта является класс, а объект представляет экземпляр этого класса. \n\nМожно еще провести следующую аналогию. \n\nУ нас у всех есть некоторое представление о человеке - наличие двух рук, двух ног, головы, туловища и т.д. \nЕсть некоторый шаблон - этот шаблон можно назвать классом. \n\nРеально же существующий человек (фактически экземпляр данного класса) является объектом этого класса. \n\nКласс определяется с помощью ключевого слова <b>сlass</b>:</string>
    <string name="lessonsOop01_03">В данном случае класс называется <b>Person</b>. \nПосле названия класса идут фигурные скобки, между которыми помещается тело класса - то есть его поля и методы. \n\nЛюбой объект может обладать двумя основными характеристиками: состояние - некоторые данные, которые хранит объект, и поведение - действия, которые может совершать объект. \n\nДля хранения состояния объекта в классе применяются поля или переменные класса. \nДля определения поведения объекта в классе применяются методы. \n\nНапример, класс <b>Person</b>, который представляет человека, мог бы иметь следующее определение:</string>
    <string name="lessonsOop01_04">В классе <b>Person</b> определены два поля: <b>name</b> представляет имя человека, а <b>age</b> - его возраст. \nИ также определен метод <b>displayInfo</b>, который ничего не возвращает и просто выводит эти данные на консоль. \nТеперь используем данный класс. \n\nДля этого определим следующую программу:</string>
    <string name="lessonsOop01_05">Как правило, классы определяются в разных файлах. \nВ данном случае для простоты мы определяем два класса в одном файле. \n\nСтоит отметить, что в этом случае только один класс может иметь модификатор <b>public</b> (в данном случае это класс <b>Program</b>), а сам файл кода должен называться по имени этого класса, то есть в данном случае файл должен называться <b>Program.java</b>. \n\nКласс представляет новый тип, поэтому мы можем определять переменные, которые представляют данный тип. \nТак, здесь в методе <b>main</b> определена переменная <b>tom</b>, которая представляет класс <b>Person</b>. \n\nНо пока эта переменная не указывает ни на какой объект и по умолчанию она имеет значение <b>null</b>. \n\nПо большому счету мы ее пока не можем использовать, поэтому вначале необходимо создать объект класса <b>Person</b>.</string>
    <string name="lessonsOop01_06">Кроме обычных методов классы могут определять специальные методы, которые называются конструкторами. \n\n<b>Конструкторы</b> вызываются при создании нового объекта данного класса. \nКонструкторы выполняют инициализацию объекта. \n\nЕсли в классе не определено ни одного конструктора, то для этого класса автоматически создается конструктор без параметров. \n\nВыше определенный класс <b>Person</b> не имеет никаких конструкторов. \nПоэтому для него автоматически создается конструктор по умолчанию, который мы можем использовать для создания объекта <b>Person</b>. \n\nВ частности, создадим один объект:</string>
    <string name="lessonsOop01_07"><u>Конструкторы</u></string>
    <string name="lessonsOop01_08">Для создания объекта <b>Person</b> используется выражение <b>new Person()</b>. \n\nОператор <b>new</b> выделяет память для объекта <b>Person</b>. \nИ затем вызывается конструктор по умолчанию, который не принимает никаких параметров. \n\nВ итоге после выполнения данного выражения в памяти будет выделен участок, где будут храниться все данные объекта <b>Person</b>. \n\nА переменная <b>tom</b> получит ссылку на созданный объект. \n\nЕсли конструктор не инициализирует значения переменных объекта, то они получают значения по умолчанию. \n\nДля переменных числовых типов это число <b>0</b>, а для типа <b>string</b> и классов - это значение <b>null</b> \n(то есть фактически отсутствие значения). \n\nПосле создания объекта мы можем обратиться к переменным объекта <b>Person</b> через переменную <b>tom</b> и установить или получить их значения.\n\nВ итоге мы увидим на консоли:</string>
    <string name="lessonsOop01_09">Если необходимо, чтобы при создании объекта производилась какая-то логика \nнапример, \nчтобы поля класса получали какие-то определенные значения, то можно определить в классе свои конструкторы. \n\nНапример:</string>
    <string name="lessonsOop01_10">Теперь в классе определено <b>три коструктора</b>, каждый из которых принимает различное количество параметров и устанавливает значения полей класса. \n\nКонсольный вывод программы:</string>
    <string name="lessonsOop01_11"><u>Ключевое слово this</u></string>
    <string name="lessonsOop01_12">Ключевое слово <b>this</b> представляет ссылку на текущий экземпляр класса. \n\nЧерез это ключевое слово мы можем обращаться к переменным, методам объекта, а также вызывать его конструкторы. \n\nНапример:</string>
    <string name="lessonsOop01_13">В третьем конструкторе параметры называются так же, как и поля класса. \nИ чтобы разграничить поля и параметры, применяется ключевое слово <b>this</b>:</string>
    <string name="lessonsOop01_14">Так, в данном случае указываем, что значение параметра <b>name</b> присваивается полю <b>name</b>. \n\nКроме того, у нас три конструктора, которые выполняют идентичные действия: устанавливают поля <b>name</b> и <b>age</b>. \n\nЧтобы избежать повторов, с помощью <b>this</b> можно вызвать один из конструкторов класса и передать для его параметров необходимые значения:</string>
    <string name="lessonsOop01_15">В итоге результат программы будет тот же, что и в предыдущем примере.</string>
    <string name="lessonsOop01_16"><u>Инициализаторы</u></string>
    <string name="lessonsOop01_17">Кроме конструктора начальную инициализацию объекта вполне можно было проводить с помощью инициализатора объекта. \nИнициализатор выполняется до любого конструктора. \n\nТо есть в инициализатор мы можем поместить код, общий для всех конструкторов:</string>
    <string name="lessonsOop01_18">Консольный вывод:</string>

    <string name="lessonsOop02_01"><u>Пакеты</u></string>
    <string name="lessonsOop02_02">Как правило, в <b>Java</b> классы объединяются в пакеты. \nПакеты позволяют организовать классы логически в наборы. \n\nПо умолчанию <b>java</b> уже имеет ряд встроенных пакетов, например, \n<b>java.lang</b>, \n<b>java.util</b>, \n<b>java.io</b> и т.д. \n\nКроме того, пакеты могут иметь вложенные пакеты. \n\nОрганизация классов в виде пакетов позволяет избежать конфликта имен между классами. \nВедь нередки ситуации, когда разработчики называют свои классы одинаковыми именами. \n\nПринадлежность к пакету позволяет гарантировать однозначность имен. \n\nЧтобы указать, что класс принадлежит определенному пакету, надо использовать директиву <b>package</b>, после которой указывается имя пакета:</string>
    <string name="lessonsOop02_03">Как правило, названия пакетов соответствуют физической структуре проекта, то есть организации каталогов, в которых находятся файлы с исходным кодом. \nА путь к файлам внутри проекта соответствует названию пакета этих файлов. \n\nНапример, если классы принадлежат пакету <b>mypack</b>, то эти классы помещаются в проекте в папку <b>mypack</b>. \n\nКлассы необязательно определять в пакеты. \nЕсли для класса пакет не определен, то считается, что данный класс находится в пакете по умолчанию, который не имеет имени. \n\nНапример, создадим в папке для исходных файлов каталог <b>study</b>. \nВ нем создадим файл <b>Program.java</b> со следующим кодом:</string>
    <string name="lessonsOop02_04">Директива <b>package study</b> в начале файла указывает, что классы <b>Program</b> и <b>Person</b>, которые здесь определены, принадлежат пакету <b>study</b>. \n\nКогда мы работаем в среде разработки, например, в <b>Netbeans</b>, то <b>IDE</b> берет на себя все вопросы компиляции пакетов и входящих в них файлов. \nСоответственно нам достаточно нажать на кнопку, и все будет готово. \nОднако если мы компилируем программу в командной строке, то мы можем столкнуться с некоторыми трудностями. Поэтому рассмотрим этот аспект. \n\nДля компиляции программы вначале в командной строке/терминале с помощью команды <b>cd</b> перейдем к папке, где находится каталог <b>study</b>.</string>
    <string name="lessonsOop02_05">Например, в моем случае это каталог <b>C:java</b> (то есть файл с исходным кодом расположен по пути \n<b>C:javastudyProgram.java</b>). \n\nДля компиляции выполним команду</string>
    <string name="lessonsOop02_06">После этого в папке <b>study</b> появятся скомпилированные файлы <b>Program.class</b> и <b>Person.class</b>. \n\nДля запуска программы выполним команду:</string>
    <string name="lessonsOop02_07"><u>Импорт пакетов и классов</u></string>
    <string name="lessonsOop02_08">Если нам надо использовать классы из других пакетов, то нам надо подключить эти пакеты и классы. \n\nИсключение составляют классы из пакета <b>java.lang</b> (например, <b>String</b>), которые подключаются в программу автоматически. \n\nНапример, знакомый по прошлым темам класс <b>Scanner</b> находится в пакете <b>java.util</b>, поэтому мы можем получить к нему доступ следующим способом:</string>
    <string name="lessonsOop02_09">То есть мы указываем полный путь к файлу в пакете при создании его объекта. \n\nОднако такое нагромождение имен пакетов не всегда удобно, и в качестве альтернативы мы можем импортировать пакеты и классы в проект с помощью директивы <b>import</b>, которая указывается после директивы <b>package</b>:</string>
    <string name="lessonsOop02_10">Директива <b>import</b> указывается в самом начале кода, после чего идет имя подключаемого класса (в данном случае класса <b>Scanner</b>). \n\nВ примере выше мы подключили только один класс, однако пакет <b>java.util</b> содержит еще множество классов. \n\nИ чтобы не подключать по отдельности каждый класс, мы можем сразу подключить весь пакет:</string>
    <string name="lessonsOop02_11">Теперь мы можем использовать любой класс из пакета <b>java.util</b>. \n\nВозможна ситуация, когда мы используем два класса с одним и тем же названием из двух разных пакетов, например, класс <b>Date</b> имеется и в пакете <b>java.util</b>, и в пакете j<b>ava.sql</b>. \n\nИ если нам надо одновременно использовать два этих класса, то необходимо указывать полный путь к этим классам в пакете:</string>
    <string name="lessonsOop02_12"><u>Статический импорт</u></string>
    <string name="lessonsOop02_13">В <b>java</b> есть также особая форма импорта - статический импорт. \n\nДля этого вместе с директивой <b>import</b> используется модификатор <b>static</b>:</string>
    <string name="lessonsOop02_14">Здесь происходит статический импорт классов <b>System</b> и <b>Math</b>. \nЭти классы имеют статические методы. \n\nБлагодаря операции статического импорта мы можем использовать эти методы без названия класса. \n\nНапример, писать не <b>Math.sqrt(20)</b>, а <b>sqrt(20)</b>, так как функция <b>sqrt()</b>, которая возвращает квадратный корень числа, является статической.\n\nТо же самое в отношении класса <b>System</b>: в нем определен статический объект <b>out</b>, поэтому мы можем его использовать без указания класса.</string>

    <string name="lessonsOop03_01"><u>Модификаторы доступа и инкапсуляция</u></string>
    <string name="lessonsOop03_02">Все члены класса в языке <b>Java</b> - поля и методы - имеют модификаторы доступа. \nВ прошлых темах мы уже сталкивались с модификатором <b>public</b>. \nМодификаторы доступа позволяют задать допустимую область видимости для членов класса, то есть контекст, в котором можно употреблять данную переменную или метод. \n\nВ Java используются следующие модификаторы доступа: \n\n<b>-public</b>: публичный, общедоступный класс или член класса. Поля и методы, объявленные с модификатором <b>public</b>, видны другим классам из текущего пакета и из внешних пакетов. \n\n<b>-private</b>: закрытый класс или член класса, противоположность модификатору <b>public</b>. Закрытый класс или член класса доступен только из кода в том же классе. \n\n<b>-protected</b>: такой класс или член класса доступен из любого места в текущем классе или пакете или в производных классах, даже если они находятся в других пакетах \n\n<b>-Модификатор по умолчанию</b>. Отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по умолчанию. \nТакие поля или методы видны всем классам в текущем пакете. \n\nРассмотрим модификаторы доступа на примере следующей программы:</string>
    <string name="lessonsOop03_03">В данном случае оба класса расположены в одном пакете - пакете по умолчанию, поэтому в классе <b>Program</b> мы можем использовать все методы и переменные класса <b>Person</b>, которые имеют модификатор по умолчанию, <b>public</b> и <b>protected</b>. \nА поля и методы с модификатором <b>private</b> в классе <b>Program</b> не будут доступны. \n\nЕсли бы класс <b>Program</b> располагался бы в другом пакете, то ему были бы доступны только поля и методы с модификатором <b>public</b>. \n\nМодификатор доступа должен предшествовать остальной части определения переменной или метода.</string>
    <string name="lessonsOop03_04"><u>Инкапсуляция</u></string>
    <string name="lessonsOop03_05">Казалось бы, почему бы не объявить все переменные и методы с модификатором <b>public</b>, чтобы они были доступны в любой точке программы вне зависимости от пакета или класса? \n\nВозьмем, например, поле <b>age</b>, которое представляет возраст. \nЕсли другой класс имеет прямой доступ к этому полю, то есть вероятность, что в процессе работы программы ему будет передано некорректное значение, например, отрицательное число. \n\nПодобное изменение данных не является желательным. \nЛибо же мы хотим, чтобы некоторые данные были достуны напрямую, чтобы их можно было вывести на консоль или просто узнать их значение. \n\nВ этой связи рекомендуется как можно больше ограничивать доступ к данным, чтобы защитить их от нежелательного доступа извне (как для получения значения, так и для его изменения). \n\nИспользование различных модификаторов гарантирует, что данные не будут искажены или изменены не надлежащим образом. \n\nПодобное сокрытие данных внутри некоторой области видимости называется <b>инкапсуляцией</b>. \n\nТак, как правило, вместо непосредственного применения полей используют методы доступа. \n\nНапример:</string>
    <string name="lessonsOop03_06">И затем вместо непосредственной работы с полями <b>name</b> и <b>age</b> в классе <b>Person</b> мы будем работать с методами, которые устанавливают и возвращают значения этих полей. \n\nМетоды <b>setName</b>, <b>setAge</b> и наподобие еще называют мьютейтерами (mutator), так как они изменяют значения поля. \n\nА методы <b>getName</b>, <b>getAge</b> и наподобие называют аксессерами (accessor), так как с их помощью мы получаем значение поля. \nПричем в эти методы мы можем вложить дополнительную логику. \n\nНапример, в данном случае при изменении возраста производится проверка, насколько соответствует новое значение допустимому диапазону.</string>

    <string name="lessonsOop04_01"><u>Статические члены и модификатор static</u></string>
    <string name="lessonsOop04_02">Кроме обычных методов и полей класс может иметь статические поля, методы, константы и инициализаторы. \n\nНапример, главный класс программы имеет метод <b>main</b>, который является статическим:</string>
    <string name="lessonsOop04_03">Для объявления статических переменных, констант, методов и инициализаторов перед их объявлением указывается ключевое слово <b>static</b>.</string>
    <string name="lessonsOop04_04"><u>Статические поля</u></string>
    <string name="lessonsOop04_05">При создании объектов класса для каждого объекта создается своя копия нестатических обычных полей. \nА статические поля являются общими для всего класса. Поэтому они могут использоваться без создания объектов класса. \n\nНапример, создадим статическую переменную:</string>
    <string name="lessonsOop04_06">Класс <b>Person</b> содержит статическую переменную <b>counter</b>, которая увеличивается в конструкторе и ее значение присваивается переменной <b>id</b>. \nТо есть при создании каждого нового объекта <b>Person</b> эта переменная будет увеличиваться, поэтому у каждого нового объекта <b>Person</b> значение поля <b>id</b> будет на 1 больше чем у предыдущего. \n\nТак как переменная <b>counter</b> статическая, то мы можем обратиться к ней в программе по имени класса:</string>
    <string name="lessonsOop04_07">Консольный вывод программы:</string>
    <string name="lessonsOop04_08"><u>Статические константы</u></string>
    <string name="lessonsOop04_09">Также статическими бывают константы, которые являются общими для всего класса.</string>
    <string name="lessonsOop04_10">Стоит отметить, что на протяжении всех предыдущих тем уже активно использовались статические константы. \n\nВ частности, в выражении:</string>
    <string name="lessonsOop04_11"><b>out</b> как раз представляет статическую константу класса <b>System</b>. \nПоэтому обращение к ней идет без создания объекта класса <b>System</b>.</string>
    <string name="lessonsOop04_12"><u>Статические инициализаторы</u></string>
    <string name="lessonsOop04_13">Статические инициализаторы предназначены для инициализации статических переменных, либо для выполнения таких действий, которые выполняются при создании самого первого объекта. \n\nНапример, определим статический инициализатор:</string>
    <string name="lessonsOop04_14">Статический инициализатор определяется как обычный, только перед ним ставится ключевое слово <b>static</b>. \nВ данном случае в статическом инициализаторе мы устанавливаем начальное значение статического поля <b>counter</b> и выводим на консоль сообщение. \nВ самой программе создаются два объекта класса <b>Person</b>. \n\nПоэтому консольный вывод будет выглядеть следующим образом:</string>
    <string name="lessonsOop04_15">Стоит учитывать, что вызов статического инициализатора производится только перед созданием самого первого объекта класса.</string>
    <string name="lessonsOop04_16"><u>Статические методы</u></string>
    <string name="lessonsOop04_17">Статические методы также относятся ко всему классу в целом. \n\nНапример, в примере выше статическая переменная <b>counter</b> была доступна извне, и мы могли изменить ее значение вне класса <b>Person</b>. \nСделаем ее недоступной для изменения извне, но доступной для чтения. \n\nДля этого используем статический метод:</string>
    <string name="lessonsOop04_18">Теперь статическая переменная недоступна извне, она приватная. А ее значение выводится с помощью статического метода <b>displayCounter</b>. \nДля обращения к статическому методу используется имя класса: \n<b>Person.displayCounter()</b>. \n\nПри использовании статических методов надо учитывать ограничения: в статических методах мы можем вызывать только другие статические методы и использовать только статические переменные. \n\nВообще методы определяются как статические, когда методы не затрагиют состояние объекта, то есть его нестатические поля и константы, и для вызова метода нет смысла создавать экземпляр класса. \n\nНапример:</string>
    <string name="lessonsOop04_19">В данном случае для методов <b>sum, subtract, multiply</b> не имеет значения, какой именно экземпляр класса <b>Operation</b> используется. \n\nЭти методы работают только с параметрами, не затрагивая состояние класса. \nПоэтому их можно определить как статические.</string>

    <string name="lessonsOop05_01"><u>Объекты как параметры методов</u></string>
    <string name="lessonsOop05_02">Объекты классов, как и данные примитивных типов, могут передаваться в методы. \nОднако в данном случае есть одна особенность - при передаче объектов в качестве значения передается копия ссылки на область в памяти, где расположен этот объект. \n\nРассмотрим небольшой пример. \n\nПусть у нас есть следующий класс <b>Person</b>:</string>
    <string name="lessonsOop05_03">Здесь в метод <b>changeName</b> передается объект <b>Person</b>, у которого изменяется имя. \nТак как в метод будет передаваться копия ссылки на область памяти, в которой находится объект <b>Person</b>, то переменная <b>kate</b> и параметр <b>p</b> метода <b>changeName</b> будут указывать на один и тот же объект в памяти. \n\nПоэтому после выполнения метода у объекта <b>kate</b>, который передается в метод, будет изменено имя с <b>Kate</b> на <b>Alice</b>. \n\nОт этого случая следует отличать другой случай:</string>
    <string name="lessonsOop05_04">В метод <b>changePerson</b> также передается копия ссылки на объект <b>Person</b>. \nОднако в самом методе мы изменяем не отдельные значения объекта, а пересоздаем объект с помощью конструктора и оператора <b>new</b>.\n\nВ результате в памяти будет выделено новое место для нового объекта <b>Person</b>, и ссылка на этот объект будет привоена параметру <b>p</b>:</string>
    <string name="lessonsOop05_05">То есть после создания нового объекта <b>Person</b> параметр <b>p</b> и переменная <b>kate</b> в методе main будут хранить ссылки на разные объекты. \n\nПеременная <b>kate</b>, которая передавалась в метод, продолжит хранить ссылку на старый объект в памяти. \nПоэтому ее значение не меняется.</string>

    <string name="lessonsOop06_01"><u>Внутренние и вложенные классы</u></string>
    <string name="lessonsOop06_02">Классы могут быть вложенными (nested), то есть могут быть определены внури других классов. \nЧастным случаем вложенных классов являются внутренние классы (inner class). \n\nНапример, имеется класс <b>Person</b>, внутри которого определен класс <b>Account</b>:</string>
    <string name="lessonsOop06_03">Внутренний класс ведет себя как обычный класс за тем исключением, что его объекты могут быть созданы только внутри внешнего класса. \n\nВнутренний класс имеет доступ ко всем полям внешнего класса, в том числе закрытым с помощью модификатора <b>private</b>. \nАналогично внешний класс имеет доступ ко всем членам внутреннего класса, в том числе к полям и методам с модификатором <b>private</b>. \n\nСсылку на объект внешнего класса из внутреннего класса можно получить с помощью выражения <b>Внешний_класс.this</b>, \nнапример, \n<b>Person.this</b>. \n\nОбъекты внутренних классов могут быть созданы только в том классе, в котором внутренние классы опеределены. \nВ других внешних классах объекты внутреннего класса создать нельзя. \n\nЕще одной особенностью внутренних классов является то, что их можно объявить внутри любого контекста, в том числе внутри метода и даже в цикле:</string>
    <string name="lessonsOop06_04"><u>Статические вложенные классы</u></string>
    <string name="lessonsOop06_05">Кроме внутренних классов также могут быть статические вложенные классы. \nСтатические вложенные классы позволяют скрыть некоторую комплексную информацию внутри внешнего класса:</string>
    <string name="lessonsOop06_06">Здесь определен вложенный класс для хранения данных о вычислении факториала. \nОсновные действия выполняет метод <b>getFactorial</b>, который возвращает объект вложенного класса. \n\nИ теперь используем классы в методе <b>main</b>:</string>

    <string name="lessonsOop07_01"><u>Наследование</u></string>
    <string name="lessonsOop07_02">Одним из ключевых аспектов объектно-ориентированного программирования является <b>наследование</b>. \nС помощью наследования можно расширить функционал уже имеющихся классов за счет добавления нового функционала или изменения старого. \n\nНапример, имеется следующий класс <b>Person</b>, описывающий отдельного человека:</string>
    <string name="lessonsOop07_03">И, возможно, впоследствии мы захотим добавить еще один класс, который описывает сотрудника предприятия - класс <b>Employee</b>. \nТак как этот класс реализует тот же функционал, что и класс <b>Person</b>, поскольку сотрудник - это также и человек, то было бы рационально сделать класс <b>Employee</b> производным (наследником, подклассом) от класса <b>Person</b>, который, в свою очередь, называется базовым классом, родителем или суперклассом:</string>
    <string name="lessonsOop07_04">Чтобы объявить один класс наследником от другого, надо использовать после имени класса-наследника ключевое слово <b>extends</b>, после которого идет имя базового класса. \nДля класса <b>Employee</b> базовым является <b>Person</b>, и поэтому класс <b>Employee</b> наследует все те же поля и методы, которые есть в классе <b>Person</b>. Использование классов:</string>
    <string name="lessonsOop07_05">Производный класс имеет доступ ко всем методам и полям базового класса (даже если базовый класс находится в другом пакете) кроме тех, которые определены с модификатором <b>private</b>. \n\nПри этом производный класс также может добавлять свои поля и методы:</string>
    <string name="lessonsOop07_06">В данном случае класс <b>Employee</b> добавляет поле <b>company</b>, которое хранит место работы сотрудника, а также метод <b>work</b>. \n\nЕсли в базовом классе определены конструкторы, то в конструкторе производного классы необходимо вызвать один из конструкторов базового класса с помощью ключевого слова <b>super</b>. \n\nНапример, класс <b>Person</b> имеет конструктор, который принимает один параметр. \nПоэтому в классе <b>Employee</b> в конструкторе нужно вызвать констуктор класса <b>Person</b>. \n\nПосле слова <b>super</b> в скобках идет перечисление передаваемых аргументов. \nТаким образом, установка имени сотрудника делегируется конструктору базового класса. \n\nПри этом вызов конструктора базового класса должен идти в самом начале в конструкторе производного класса.</string>
    <string name="lessonsOop07_07"><u>Переопределение методов</u></string>
    <string name="lessonsOop07_08">Производный класс может определять свои методы, а может переопределять методы, которые унаследованы от базового класса. \n\nНапример, переопределим в классе <b>Employee</b> метод <b>display</b>:</string>
    <string name="lessonsOop07_09">Перед переопределяемым методом указывается аннотация <b>@Override</b>. \nДанная аннотация в принципе необязательна. \n\nПри переопределении метода он должен иметь уровень доступа не меньше, чем уровень доступа в базовом класса. \n\nНапример, если в базовом классе метод имеет модификатор <b>public</b>, то и в производном классе метод должен иметь модификатор <b>public</b>. \n\nОднако в данном случае мы видим, что часть метода <b>display</b> в <b>Employee</b> повторяет действия из метода <b>display</b> базового класса. \n\nПоэтому мы можем сократить класс <b>Employee</b>:</string>
    <string name="lessonsOop07_10">С помощью ключевого слова <b>super</b> мы также можем обратиться к реализации методов базового класса.</string>
    <string name="lessonsOop07_11"><u>Запрет наследования</u></string>
    <string name="lessonsOop07_12">Хотя наследование очень интересный и эффективный механизм, но в некоторых ситуациях его применение может быть нежелательным. \nИ в этом случае можно запретить наследование с помощью ключевого слова <b>final</b>. \n\nНапример:</string>
    <string name="lessonsOop07_13">Если бы класс <b>Person</b> был бы определен таким образом, то следующий код был бы ошибочным и не сработал, так как мы тем самым запретили наследование:</string>
    <string name="lessonsOop07_14">Кроме запрета наследования можно также запретить переопределение отдельных методов. \n\nНапример, в примере выше переопределен метод <b>display()</b>, запретим его переопределение:</string>
    <string name="lessonsOop07_15">В этом случае класс <b>Employee</b> не сможет переопределить метод <b>display</b>.</string>
    <string name="lessonsOop07_16"><u>Динамическая диспетчеризация методов</u></string>
    <string name="lessonsOop07_17">Наследование и возможность переопределения методов открывают нам большие возможности. \nПрежде всего мы можем передать переменной суперкласса ссылку на объект подкласса:</string>
    <string name="lessonsOop07_18">Так как <b>Employee</b> наследуется от <b>Person</b>, то объект <b>Employee</b> является в то же время и объектом <b>Person</b>. \nГрубо говоря, любой работник предприятия одновременно является человеком. \n\nОднако несмотря на то, что переменная представляет объект <b>Person</b>, виртуальная машина видит, что в реальности она указывает на объект <b>Employee</b>. \n\nПоэтому при вызове методов у этого объекта будет вызываться та версия метода, которая определена в классе <b>Employee</b>, а не в <b>Person</b>. \n\nНапример:</string>
    <string name="lessonsOop07_19">Консольный вывод данной программы:</string>
    <string name="lessonsOop07_20">При вызове переопределенного метода виртуальная машина динамически находит и вызывает именно ту версию метода, которая определена в подклассе. \n\nДанный процесс еще называется <b>dynamic method lookup</b> или динамический поиск метода или динамическая диспетчеризация методов.</string>

    <string name="lessonsOop08_01"><u>Абстрактные классы</u></string>
    <string name="lessonsOop08_02">Кроме обычных классов в <b>Java</b> есть <b>абстрактные классы</b>. \nАбстрактный класс похож на обычный класс. В абстрактном классе также можно определить поля и методы, но в то же время нельзя создать объект или экземпляр абстрактного класса. \n\nАбстрактные классы призваны предоставлять базовый функционал для классов-наследников. \nА производные классы уже реализуют этот функционал. \n\nПри определении абстрактных классов используется ключевое слово <b>abstract</b>:</string>
    <string name="lessonsOop08_03">Но главное отличие состоит в том, что мы не можем использовать конструктор абстрактного класса для создания его объекта. \n\nНапример, следующим образом:</string>
    <string name="lessonsOop08_04">Кроме обычных методов абстрактный класс может содержать абстрактные методы. \nТакие методы определяются с помощью ключевого слова <b>abstract</b> и не имеют никакой реализации:</string>
    <string name="lessonsOop08_05">Производный класс обязан переопределить и реализовать все абстрактные методы, которые имеются в базовом абстрактном классе. \n\nТакже следует учитывать, что если класс имеет хотя бы один абстрактный метод, то данный класс должен быть определен как абстрактный. \n\nЗачем нужны абстрактные классы? \n\nДопустим, мы делаем программу для обслуживания банковских операций и определяем в ней три класса: <b>Person</b>, который описывает человека, <b>Employee</b>, который описывает банковского служащего, и класс <b>Client</b>, который представляет клиента банка. \n\nОчевидно, что классы <b>Employee</b> и <b>Client</b> будут производными от класса <b>Person</b>, так как оба класса имеют некоторые общие поля и методы. \nИ так как все объекты будут представлять либо сотрудника, либо клиента банка, то напрямую мы от класса <b>Person</b> создавать объекты не будем. \nПоэтому имеет смысл сделать его абстрактным.</string>
    <string name="lessonsOop08_06">Другим хрестоматийным примером является система геометрических фигур. \nВ реальности не существует геометрической фигуры как таковой. \n\nЕсть круг, прямоугольник, квадрат, но просто фигуры нет. \nОднако же и круг, и прямоугольник имеют что-то общее и являются фигурами:</string>

    <string name="lessonsOop09_01"><u>Иерархия наследования и преобразование типов</u></string>
    <string name="lessonsOop09_02">В прошлой главе говорилось о преобразованиях объектов простых типов. Однако с объектами классов все происходит немного по-другому. \n\nДопустим, у нас есть следующая иерархия классов:</string>
    <string name="lessonsOop09_03">В этой иерархии классов можно проследить следующую цепь наследования: \n\n<b>Object</b> (все классы неявно наследуются от типа Object) \n-> Person -> Employee</string>
    <string name="lessonsOop09_04">Суперклассы обычно размещаются выше подклассов, поэтому на вершине наследования находится класс <b>Object</b>, а в самом низу <b>Employee</b> и <b>Client</b>. \nОбъект подкласса также представляет объект суперкласса. \n\nПоэтому в программе мы можем написать следующим образом:</string>
    <string name="lessonsOop09_05">Это так называемое восходящее преобразование (от подкласса внизу к суперклассу вверху иерархии) или <b>upcasting</b>. \nТакое преобразование осуществляется автоматически. Обратное не всегда верно. \n\nНапример, объект <b>Person</b> не всегда является объектом <b>Employee</b> или <b>Client</b>. \nПоэтому нисходящее преобразование или <b>downcasting</b> от суперкласса к подклассу автоматически не выполняется. \n\nВ этом случае нам надо использовать операцию преобразования типов.</string>
    <string name="lessonsOop09_06">В данном случае переменная <b>sam</b> приводится к типу <b>Employee</b>. \nИ затем через объект <b>emp</b> мы можем обратиться к функционалу объекта <b>Employee</b>. \n\nМы можем преобразовать объект <b>Employee</b> по всей прямой линии наследования от <b>Object</b> к <b>Employee</b>. \n\nПримеры нисходящих перобразований:</string>
    <string name="lessonsOop09_07">Но рассмотрим еще одну ситуацию:</string>
    <string name="lessonsOop09_08">В данном случае переменная типа <b>Object</b> хранит ссылку на объект <b>Client</b>. \nМы можем без ошибок привести этот объект к типам <b>Person</b> или <b>Client</b>. \n\nНо при попытке преобразования к типу <b>Employee</b> мы получим ошибку во время выполнения. \nТак как <b>kate</b> не представляет объект типа <b>Employee</b>. \nЗдесь мы явно видим, что переменная <b>kate</b> - это ссылка на объект <b>Client</b>, а не <b>Employee</b>. \n\nОднако нередко данные приходят извне, и мы можем точно не знать, какой именно объект эти данные представляют. \nСоответственно возникает большая вероятность столкнуться с ошибкой. \n\nИ перед тем, как провести преобразование типов, мы можем проверить, а можем ли мы выполнить приведение с помощью оператора <b>instanceof</b>:</string>
    <string name="lessonsOop09_09">Выражение <b>kate instanceof Employee</b> проверяет, является ли переменная <b>kate</b> объектом типа <b>Employee</b>. \nНо так как в данном случае явно не является, то такая проверка вернет значение <b>false</b>, и преобразование не сработает.</string>

    <string name="lessonsOop10_01"><u>Интерфейсы</u></string>
    <string name="lessonsOop10_02">Механизм наследования очень удобен, но он имеет свои ограничения. \nВ частности мы можем наследовать только от одного класса, в отличие, например, от языка <b>С++</b>, где имеется множественное наследование. \n\nВ языке Java подобную проблему частично позволяют решить интерфейсы. \nИнтерфейсы определяют некоторый функционал, не имеющий конкретной реализации, который затем реализуют классы, применяющие эти интерфейсы. \nИ один класс может применить множество интерфейсов. \n\nЧтобы определить интерфейс, используется ключевое слово <b>interface</b>. \n\nНапример:</string>
    <string name="lessonsOop10_03">Данный интерфейс называется <b>Printable</b>. \nИнтерфейс может определять константы и методы, которые могут иметь, а могут и не иметь реализации. \nМетоды без реализации похожи на абстрактные методы абстрактных классов. Так, в данном случае объявлен один метод, который не имеет реализации. \n\nВсе методы интерфейса не имеют модификаторов доступа, но фактически по умолчанию доступ <b>public</b>, так как цель интерфейса - определение функционала для реализации его классом. \nПоэтому весь функционал должен быть открыт для реализации. \n\nЧтобы класс применил интерфейс, надо использовать ключевое слово <b>implements</b>:</string>
    <string name="lessonsOop10_04">В данном случае класс <b>Book</b> реализует интерфейс <b>Printable</b>. При этом надо учитывать, что если класс применяет интерфейс, то он должен реализовать все методы интерфейса, как в случае выше реализован метод <b>print</b>. \n\nПотом в методе <b>main</b> мы можем создать объект класса <b>Book</b> и вызвать его метод <b>print</b>. \n\nЕсли класс не реализует какие-то методы интерфейса, то такой класс должен быть определен как абстрактный, а его неабстрактные классы-наследники затем должны будут реализовать эти методы.\n\nВ тоже время мы не можем напрямую создавать объекты интерфейсов, поэтому следующий код не будет работать:</string>
    <string name="lessonsOop10_05">Одним из преимуществ использования интерфейсов является то, что они позволяют добавить в приложение гибкости. \n\nНапример, в дополнение к классу <b>Book</b> определим еще один класс, который будет реализовывать интерфейс <b>Printable</b>:</string>
    <string name="lessonsOop10_06">Класс <b>Book</b> и класс <b>Journal</b> связаны тем, что они реализуют интерфейс <b>Printable</b>. \nПоэтому мы динамически в программе можем создавать объекты <b>Printable</b> как экземпляры обоих классов:</string>
    <string name="lessonsOop10_07"><u>Интерфейсы в преобразованиях типов</u></string>
    <string name="lessonsOop10_08">Все сказанное в отношении преобразования типов характерно и для интерфейсов. \n\nНапример, так как класс <b>Journal</b> реализует интерфейс <b>Printable</b>, то переменная типа <b>Printable</b> может хранить ссылку на объект типа <b>Journal</b>:</string>
    <string name="lessonsOop10_09">И если мы хотим обратиться к методам класса <b>Journal</b>, которые определены не в интерфейсе <b>Printable</b>, а в самом классе <b>Journal</b>, то нам надо явным образом выполнить преобразование типов: \n\n<b>((Journal)p).getName();</b></string>
    <string name="lessonsOop10_10"><u>Методы по умолчанию</u></string>
    <string name="lessonsOop10_11">Ранее до <b>JDK 8</b> при реализации интерфейса мы должны были обязательно реализовать все его методы в классе. А сам интерфейс мог содержать только определения методов без конкретной реализации. \n\nВ <b>JDK 8</b> была добавлена такая функциональность как методы по умолчанию. \nИ теперь интерфейсы кроме определения методов могут иметь их реализацию по умолчанию, которая используется, если класс, реализующий данный интерфейс, не реализует метод. \n\nНапример, создадим метод по умолчанию в интерфейсе <b>Printable</b>:</string>
    <string name="lessonsOop10_12">Метод по умолчанию - это обычный метод без модификаторов, который помечается ключевым словом <b>default</b>. \n\nЗатем в классе <b>Journal</b> нам необязательно этот метод реализовать, хотя мы можем его и переопределить:</string>
    <string name="lessonsOop10_13"><u>Статические методы</u></string>
    <string name="lessonsOop10_14">Начиная с <b>JDK 8</b> в интерфейсах доступны статические методы - они аналогичны методам класса:</string>
    <string name="lessonsOop10_15">Чтобы обратиться к статическому методу интерфейса также, как и в случае с классами, пишут название интерфейса и метод:</string>
    <string name="lessonsOop10_16"><u>Приватные методы</u></string>
    <string name="lessonsOop10_17">По умолчанию все методы в интерфейсе фактически имеют модификатор <b>public</b>. \n\nОднако начиная с <b>Java 9</b> мы также можем определять в интерфейсе методы с модификатором <b>private</b>. \nОни могут быть статическими и нестатическими, но они не могут иметь реализации по умолчанию. \n\nПодобные методы могут использоваться только внутри самого интерфейса, в котором они определены. \nТо есть к примеру нам надо выполнять в интерфейсе некоторые повторяющиеся действия, и в этом случае такие действия можно выделить в приватные методы:</string>
    <string name="lessonsOop10_18"><u>Константы в интерфейсах</u></string>
    <string name="lessonsOop10_19">Кроме методов в интерфейсах могут быть определены статические константы:</string>
    <string name="lessonsOop10_20">Хотя такие константы также не имеют модификаторов, но по умолчанию они имеют модификатор доступа <b>public static final</b>, и поэтому их значение доступно из любого места программы. \n\nПрименение констант:</string>
    <string name="lessonsOop10_21"><u>Множественная реализация интерфейсов</u></string>
    <string name="lessonsOop10_22">Если нам надо применить в классе несколько интерфейсов, то они все перечисляются через запятую после слова <b>implements</b>:</string>
    <string name="lessonsOop10_23"><u>Наследование интерфейсов</u></string>
    <string name="lessonsOop10_24">Интерфейсы, как и классы, могут наследоваться:</string>
    <string name="lessonsOop10_25">При применении этого интерфейса класс <b>Book</b> должен будет реализовать как методы интерфейса <b>BookPrintable</b>, так и методы базового интерфейса <b>Printable</b>.</string>
    <string name="lessonsOop10_26"><u>Вложенные интерфейсы</u></string>
    <string name="lessonsOop10_27">Как и классы, интерфейсы могут быть вложенными, то есть могут быть определены в классах или других интерфейсах. \n\nНапример:</string>
    <string name="lessonsOop10_28">При применении такого интерфейса нам надо указывать его полное имя вместе с именем класса:</string>
    <string name="lessonsOop10_29">Использование интерфейса будет аналогично предыдущим случаям:</string>
    <string name="lessonsOop10_30"><u>Интерфейсы как параметры и результаты методов</u></string>
    <string name="lessonsOop10_31">И также как и в случае с классами, интерфейсы могут использоваться в качестве типа параметров метода или в качестве возвращаемого типа:</string>
    <string name="lessonsOop10_32">Метод <b>read()</b> в качестве параметра принимает объект интерфейса <b>Printable</b>, поэтому в этот метод мы можем передать как объект <b>Book</b>, так и объект <b>Journal</b>. \n\nМетод <b>createPrintable()</b> возвращает объект <b>Printable</b>, поэтому также мы можем возвратить как объект <b>Book</b>, так и <b>Journal</b>. \n\nКонсольный вывод:</string>

    <string name="lessonsOop11_01"><u>Интерфейсы в механизме обратного вызова</u></string>
    <string name="lessonsOop11_02">Одним из распространенных способов использования интерфейсов в <b>Java</b> является создание обратного вызова. \nСуть обратного вызова состоит в том, что мы создаем действия, которые вызываются при других действиях. То есть одни действия вызываются другими действиями. \n\nСтандартный пример - нажатие на кнопку. \nКогда мы нажимаем на кнопку, мы производим действие, но в ответ на это нажатие запускаются другие действия. \n\nНапример, нажатие на значок принтера запускает печать документа на принтере и т.д. \n\nРассмотрим следующий пример:</string>
    <string name="lessonsOop11_03">Итак, здесь у нас определен класс <b>Button</b>, который в конструкторе принимает объект интерфейса <b>EventHandler</b> и в методе <b>click</b> (имитация нажатия) вызывает метод <b>execute</b> этого объекта. \n\nДалее определяется реализация <b>EventHandler</b> в виде класса <b>ButtonClickHandler</b>. \n\nИ в основной программе объект этого класса передается в конструктор <b>Button</b>. \nТаким образом, через конструктор мы устанавливаем обработчик нажатия кнопки. \nИ при каждом вызове метода <b>button.click()</b> будет вызываться этот обработчик. \n\nВ итоге программа выведет на консоль следующий результат:</string>
    <string name="lessonsOop11_04">Но казалось бы, зачем нам выносить все действия в интерфейс, его реализовать, почему бы не написать проще сразу в классе <b>Button</b>:</string>
    <string name="lessonsOop11_05">Дело в том, что на момент определения класса нам не всегда бывают точно известны те действия, которые должны производиться. \nОсобенно если класс <b>Button</b> и класс основной программы находятся в разных пакетах, библиотеках и могут проектироваться разными разработчиками. \n\nК тому же у нас может быть несколько кнопок - объектов <b>Button</b> и для каждого объекта надо определить свое действие. \n\nНапример, изменим главный класс программы:</string>
    <string name="lessonsOop11_06">Здесь у нас две кнопки - одна для включения-выключения телевизора, а другая для печати на принтере. \n\nВместо того, чтобы создавать отдельные классы, реализующие интерфейс <b>EventHandler</b>, здесь обработчики задаются в виде анонимных объектов, которые реализуют интерфейс <b>EventHandler</b>. \nПричем обработчик кнопки телевизора хранит дополнительное состояние в виде логической переменной on. \n\nВ итоге консоль выведет нам следующий результат:</string>
    <string name="lessonsOop11_07">И в завершении надо сказать, что интерфейсы в данном качестве особенно широко используются в различных графических \n<b>API - AWT, Swing, JavaFX</b>, где обработка событий объектов - элементов графического интерфейса особенно актуальна.</string>

    <string name="lessonsOop12_01"><u>Перечисления enum</u></string>
    <string name="lessonsOop12_02">Кроме отдельных примитивных типов данных и классов в <b>Java</b> есть такой тип как <b>enum</b> или перечисление. \nПеречисления представляют набор логически связанных констант. Объявление перечисления происходит с помощью оператора <b>enum</b>, после которого идет название перечисления. \n\nЗатем идет список элементов перечисления через запятую:</string>
    <string name="lessonsOop12_03">Перечисление фактически представляет новый тип, поэтому мы можем определить переменную данного типа и использовать ее:</string>
    <string name="lessonsOop12_04">Перечисления могут использоваться в классах для хранения данных:</string>
    <string name="lessonsOop12_05">Само перечисление объявлено вне класса, оно содержит четыре жанра книг. \nКласс <b>Book</b> кроме обычных переменных содержит также переменную типа нашего перечисления. \nВ конструкторе мы ее также можем присвоить, как и обычные поля класса. \nС помощью конструкции <b>switch..case</b> можно проверить принадлежность значения <b>bookType</b> определенной константе перечисления.</string>
    <string name="lessonsOop12_06"><u>Методы перечислений</u></string>
    <string name="lessonsOop12_07">Каждое перечисление имеет статический метод <b>values()</b>. \n\nОн возвращает массив всех констант перечисления:</string>
    <string name="lessonsOop12_08">Метод <b>ordinal()</b> возвращает порядковый номер определенной константы \n(нумерация начинается с 0):</string>
    <string name="lessonsOop12_09"><u>Конструкторы, поля и методы перечисления</u></string>
    <string name="lessonsOop12_10">Перечисления, как и обычные классы, могут определять конструкторы, поля и методы. \n\nНапример:</string>
    <string name="lessonsOop12_11">Перечисление <b>Color</b> определяет приватное поле code для хранения кода цвета, а с помощью метода <b>getCode</b> оно возвращается. \n\nЧерез конструктор передается для него значение. Следует отметить, что конструктор по умолчанию приватный, то есть имеет модификатор <b>private</b>. \n\nЛюбой другой модификатор будет считаться ошибкой. \nПоэтому создать константы перечисления с помощью конструктора мы можем только внутри перечисления. \n\nТакже можно определять методы для отдельных констант:</string>

    <string name="lessonsOop13_01"><u>Класс Object и его методы</u></string>
    <string name="lessonsOop13_02">Хотя мы можем создать обычный класс, который не является наследником, но фактически все классы наследуются от класса <b>Object</b>. \n\nВсе остальные классы, даже те, которые мы добавляем в свой проект, являются неявно производными от класса <b>Object</b>. \NПоэтому все типы и классы могут реализовать те методы, которые определены в классе <b>Object</b>. \n\nРассмотрим эти методы.</string>
    <string name="lessonsOop13_03">Полученное мной значение (в данном случае Person@7960847b) вряд ли может служить хорошим строковым описанием объекта. \nПоэтому метод <b>toString()</b> нередко переопределяют. \n\nНапример:</string>
    <string name="lessonsOop13_04"><u>Метод hashCode</u></string>
    <string name="lessonsOop13_05">Метод <b>hashCode</b> позволяет задать некоторое числовое значение, которое будет соответствовать данному объекту или его хэш-код. \nПо данному числу, например, можно сравнивать объекты. \n\nНапример, выведем представление вышеопределенного объекта:</string>
    <string name="lessonsOop13_06">Но мы можем задать свой алгоритм определения хэш-кода объекта:</string>
    <string name="lessonsOop13_07"><u>Получение типа объекта и метод getClass</u></string>
    <string name="lessonsOop13_08">Метод <b>getClass</b> позволяет получить тип данного объекта:</string>
    <string name="lessonsOop13_09"><u>Метод equals</u></string>
    <string name="lessonsOop13_10">Метод <b>equals</b> сравнивает два объекта на равенство:</string>
    <string name="lessonsOop13_11">Метод <b>equals</b> принимает в качестве параметра объект любого типа, который мы затем приводим к текущему, если они являются объектами одного класса. \n\nОператор <b>instanceof</b> позволяет выяснить, является ли переданный в качестве параметра объект объектом определенного класса, в данном случае класса <b>Person</b>. \nЕсли объекты принадлежат к разным классам, то их сравнение не имеет смысла, и возвращается значение <b>false</b>. Затем сравниваем по именам. \n\nЕсли они совпадают, возвращаем <b>true</b>, что будет говорить, что объекты равны.</string>
    <string name="lessonsOop13_12"><u>toString</u></string>
    <string name="lessonsOop13_13">Метод <b>toString</b> служит для получения представления данного объекта в виде строки. \nПри попытке вывести строковое представления какого-нибудь объекта, как правило, будет выводиться полное имя класса. \n\nНапример:</string>

    <string name="lessonsOop14_01"><u>Обобщения (Generics)</u></string>
    <string name="lessonsOop14_02"><b>Обобщения</b> или <b>generics</b> (обобщенные типы и методы) позволяют нам уйти от жесткого определения используемых типов. \nРассмотрим проблему, в которой они нам могут понадобиться. \n\nДопустим, мы определяем класс для представления банковского счета. \nК примеру, он мог бы выглядеть следующим образом:</string>
    <string name="lessonsOop14_03">Класс <b>Account</b> имеет два поля: \n<b>id</b> - уникальный идентификатор счета и <b>sum</b> - сумма на счете. \n\nВ данном случае идентификатор задан как целочисленное значение, например, 1, 2, 3, 4 и так далее. Однако также нередко для идентификатора используются и строковые значения. \n\nИ числовые, и строковые значения имеют свои плюсы и минусы. И на момент написания класса мы можем точно не знать, что лучше выбрать для хранения идентификатора - строки или числа. \nЛибо, возможно, этот класс будет использоваться другими разработчиками, которые могут иметь свое мнение по данной проблеме. \n\nНапример, в качестве типа <b>id</b> они захотят использовать какой-то свой класс. \n\nИ на первый взгляд мы можем решить данную проблему следующим образом: задать <b>id</b> как поле типа <b>Object</b>, который является универсальным и базовым суперклассом для всех остальных типов:</string>
    <string name="lessonsOop14_04">В данном случае все замечательно работает. Однако тогда мы сталкиваемся с проблемой <b>безопасности типов</b>. \n\nНапример, в следующем случае мы получим ошибку:</string>
    <string name="lessonsOop14_05">Проблема может показаться искуственной, так как в данном случае мы видим, что в конструктор передается строка, поэтому мы вряд ли будем пытаться преобразовывать ее к типу <b>int</b>. \nОднако в процессе разработки мы можем не знать, какой именно тип представляет значение в <b>id</b>, и при попытке получить число в данном случае мы столкнемся с исключением <b>java.lang.ClassCastException</b>. \n\nПисать для каждого отдельного типа свою версию класса <b>Account</b> тоже не является хорошим решением, так как в этом случае мы вынуждены повторяться. \n\nЭти проблемы были призваны устранить <b>обобщения</b> или <b>generics</b>. \nОбобщения позволяют не указывать конкретный тип, который будет использоваться. \n\nПоэтому определим класс <b>Account</b> как обобщенный:</string>
    <string name="lessonsOop14_06">С помощью буквы <b>T</b> в определении класса <b>class Account &#60;T&#62;</b> мы указываем, что данный тип <b>T</b> будет использоваться этим классом. \nПараметр <b>T</b> в угловых скобках называется универсальным параметром, так как вместо него можно подставить любой тип. При этом пока мы не знаем, какой именно это будет тип: <b>String</b>, <b>int</b> или какой-то другой. \nПричем буква <b>T</b> выбрана условно, это может и любая другая буква или набор символов. \n\nПосле объявления класса мы можем применить универсальный параметр <b>T</b>: так далее в классе объявляется переменная этого типа, которой затем присваивается значение в конструкторе. \n\nМетод <b>getId()</b> возвращает значение переменной <b>id</b>, но так как данная переменная представляет тип <b>T</b>, то данный метод также возвращает объект типа <b>T</b>: <b>public T getId()</b>. \n\nИспользуем данный класс:</string>
    <string name="lessonsOop14_07">При определении переменной даннного класса и создании объекта после имени класса в угловых скобках нужно указать, какой именно тип будет использоваться вместо универсального параметра. \n\nПри этом надо учитывать, что они работают только с объектами, но не работают с примитивными типами. \nТо есть мы можем написать <b>Account&#60;Integer&#62;</b>, но не можем использовать тип <b>int</b> или <b>double</b>, например, <b>Account&#60;int&#62;</b>. \nВместо примитивных типов надо использовать классы-обертки: <b>Integer</b> вместо <b>int</b>, <b>Double</b> вместо <b>double</b> и т.д. \n\nНапример, первый объект будет использовать тип <b>String</b>, то есть вместо <b>T</b> будет подставляться <b>String</b>:</string>
    <string name="lessonsOop14_08">В этом случае в качестве первого параметра в конструктор передается строка. А второй объект использует тип <b>int (Integer)</b>:</string>
    <string name="lessonsOop14_09"><u>Обобщенные интерфейсы</u></string>
    <string name="lessonsOop14_10">Интерфейсы, как и классы, также могут быть обобщенными. \n\nСоздадим обобщенный интерфейс <b>Accountable</b> и используем его в программе:</string>
    <string name="lessonsOop14_11">При реализации подобного интерфейса есть две стратегии. В данном случае реализована первая стратегия, когда при реализации для универсального параметра интерфейса задается конкретный тип, как например, в данном случае это тип <b>String</b>. \nТогда класс, реализующий интерфейс, жестко привязан к этому типу. \n\nВторая стратегия представляет определение обобщенного класса, который также использует тот же универсальный параметр:</string>
    <string name="lessonsOop14_12"><u>Обобщенные методы</u></string>
    <string name="lessonsOop14_13">Кроме обобщенных типов можно также создавать обобщенные методы, которые точно также будут использовать универсальные параметры. \n\nНапример:</string>
    <string name="lessonsOop14_14">Особенностью обобщенного метода является использование универсального параметра в объявлении метода после всех модификаторов и перед типом возвращаемого значения.</string>
    <string name="lessonsOop14_15">Затем внутри метода все значения типа <b>T</b> будут представлять данный универсальный параметр. \n\nПри вызове подобного метода перед его именем в угловых скобках указывается, какой тип будет передаваться на место универсального параметра:</string>
    <string name="lessonsOop14_16"><u>Использование нескольких универсальных параметров</u></string>
    <string name="lessonsOop14_17">Мы можем также задать сразу несколько универсальных параметров:</string>
    <string name="lessonsOop14_18">В данном случае тип <b>String</b> будет передаваться на место параметра <b>T</b>, а тип <b>Double</b> - на место параметра <b>S</b></string>
    <string name="lessonsOop14_19"><u>Обобщенные конструкторы</u></string>
    <string name="lessonsOop14_20">Конструкторы как и методы также могут быть обобщенными. \nВ этом случае перед конструктором также указываются в угловых скобках универсальные параметры:</string>
    <string name="lessonsOop14_21">В данном случае конструктор принимает параметр <b>id</b>, который представляет тип <b>T</b>. \nВ конструкторе его значение превращается в строку и сохраняется в локальную переменную.</string>

    <string name="lessonsOop15_01"><u>Ограничения обобщений</u></string>
    <string name="lessonsOop15_02">Когда мы указываем универсальный параметр у обобщений, то по умолчанию он может представлять любой тип. \nОднако иногда необходимо, чтобы параметр соответствовал только некоторому ограниченному набору типов. В этом случае применяются ограничения, которые позволяют указать базовый класс, которому должен соответствовать параметр. \n\nДля установки ограничения после универсального параметра ставится слово <b>extends</b>, после которого указывается базовый класс ограничения:</string>
    <string name="lessonsOop15_03">К примеру, в данном случае для параметра <b>T</b> в <b>Transaction</b> ограничением является класс <b>Account</b>. \nТо есть на место параметра <b>T</b> мы можем передать либо класс <b>Account</b>, либо один из его классов-наследников. \n\nНапример, рассмотрим следующую программу:</string>
    <string name="lessonsOop15_04">В данном случае класс <b>Transaction</b>, который представляет операцию перевода средств между двумя счетами, типизирован параметром <b>T</b>, у которого в качестве ограничения установлен класс <b>Account</b>. \nПри создании объекта <b>Transaction</b> в его конструктор передаются два объекта <b>Account</b> - два счета, между которыми надо осуществить перевод, и сумма перевода. \n\nПри этом важно понимать, что поскольку мы установили подобное ограничение, то компилятор будет распознавать объекты типа <b>T</b> как объекты типа <b>Account</b>.\n И в этом случае мы можем вызывать у объектов типа <b>T</b> методы класса <b>Account</b>. \n\nИ мы бы не смогли бы это сделать, если бы мы не задали подобного ограничения:</string>
    <string name="lessonsOop15_05">В этом случае была бы ошибка.</string>
    <string name="lessonsOop15_06"><u>Обобщенные типы в качестве ограничений</u></string>
    <string name="lessonsOop15_07">В качестве ограничений могут выступать и другие обобщения, которые сами могут иметь ограничения:</string>
    <string name="lessonsOop15_08">В данном случае ограничением для <b>Transaction</b> является тип <b>Account</b>, который типизирован типом <b>String</b>.</string>
    <string name="lessonsOop15_09"><u>Интерфейсы в качестве оганичений</u></string>
    <string name="lessonsOop15_10">В качестве ограничений могут выступать также интерфейсы. \n\nВ этом случае передаваемый на место универсального параметра тип должен реализовать данный интерфейс:</string>
    <string name="lessonsOop15_11"><u>Множественные ограничения</u></string>
    <string name="lessonsOop15_12">Также можно установить сразу несколько ограничений. \n\nНапример, пусть класс <b>Transaction</b> может работать только с объектами, которые одновременно реализуют интерфейс <b>Accountable</b> и являются наследниками класса <b>Person</b>:</string>

    <string name="lessonsOop16_01"><u>Наследование и обобщения</u></string>
    <string name="lessonsOop16_02">Обобщенные классы могут участвовать в иерархии наследования: могут наследоваться от других, либо выполнять роль базовых классов. \n\nРассмотрим различные ситуации.</string>
    <string name="lessonsOop16_03"><u>Базовый обобщенный класс</u></string>
    <string name="lessonsOop16_04">При наследовании от обобщенного класса класс-наследник должен передавать данные о типе в конструкции базового класса:</string>
    <string name="lessonsOop16_05">В конструкторе <b>DepositAccount</b> идет обращение к конструктору базового класса, в который передаются данные о типе. \n\nВарианты использования классов:</string>
    <string name="lessonsOop16_06">При этом класс-наследник может добавлять и использовать какие-то свои параметры типов:</string>
    <string name="lessonsOop16_07">Варианты использования:</string>
    <string name="lessonsOop16_08">И еще одна ситуация - класс-наследник вообще может не быть обобщенным:</string>
    <string name="lessonsOop16_09">Здесь при наследовании явным образом указывается тип, который будет использоваться конструкциями базового класса, то есть тип <b>Integer</b>. \nЗатем в конструктор базового класса передается значение именно этого типа - в данном случае число <b>5</b>. \n\nВариант использования:</string>
    <string name="lessonsOop16_10"><u>Обобщенный класс-наследник</u></string>
    <string name="lessonsOop16_11">Также может быть ситуация, когда базовый класс является обычным необобщенным классом. \n\nНапример:</string>
    <string name="lessonsOop16_12">В этом случае использование конструкций базового класса в наследнике происходит как обычно.</string>
    <string name="lessonsOop16_13"><u>Преобразование обобщенных типов</u></string>
    <string name="lessonsOop16_14">Объект одного обобщенного типа можно привести к другому типу, если они используют один и тот же тип. \n\nРассмотрим преобразование типов на примере следующих двух обобщенных классов:</string>
    <string name="lessonsOop16_15">Мы можем привести объект <b>DepositAccount&#60;Integer&#62;</b> к <b>Account&#60;Integer&#62;</b> или <b>DepositAccount&#60;String&#62;</b> к <b>Account&#60;String&#62;</b>:</string>
    <string name="lessonsOop16_16">Но сделать то же самое с разнотипными объектами мы не можем. Например, следующий код не будет работать:</string>

    <string name="lessonsOop17_01"><u>Ссылочные типы и копирование объектов</u></string>
    <string name="lessonsOop17_02">При работе с объектами классов надо учитывать, что они все представляют ссылочные типы, то есть указывают на какой-то объект, расположенный в памяти. \n\nЧтобы понять возможные трудности, с которыми мы можем столкнуться, рассмотрим пример:</string>
    <string name="lessonsOop17_03">Здесь создаем два объекта <b>Person</b> и один присваиваем другому. \nНо, несмотря на то, что мы изменяем только объект <b>bob</b>, вместе с ним изменяется и объект <b>tom</b>. \n\nПотому что после присвоения они указывают на одну и ту же область в памяти, где собственно данные об объекте <b>Person</b> и его полях и хранятся.</string>
    <string name="lessonsOop17_04">Чтобы избежать этой проблемы, необходимо создать отдельный объект для переменной <b>bob</b>, например, с помощью метода <b>clone</b>:</string>
    <string name="lessonsOop17_05">Для реализации клонирования класс <b>Person</b> должен применить интерфейс <b>Cloneable</b>, который определяет метод <b>clone</b>. \n\nРеализация этого метода просто возвращает вызов метода <b>clone</b> для родительского класса - то есть класса <b>Object</b> с преобразованием к типу <b>Person</b>. \nКроме того, на случай если класс не поддерживает клонирование, метод должен выбрасывать исключение <b>CloneNotSupportedException</b>, что определяется с помощью оператора <b>throws</b>. \n\nЗатем с помощью вызова этого метода мы можем осуществить копирование:</string>
    <string name="lessonsOop17_06">Однако данный способ осуществляет неполное копирование и подойдет, если клонируемый объект не содержит сложных объектов. \n\nНапример, пусть класс <b>Book</b> имеет следующее определение:</string>
    <string name="lessonsOop17_07">Если мы попробуем изменить автора книги, нас постигнет неудача:</string>
    <string name="lessonsOop17_08">В этом случае, хотя переменные <b>book</b> и <b>book2</b> будут указывать на разные объекты в памяти, но эти объекты при этом будут указывать на один объект <b>Author</b>.</string>
    <string name="lessonsOop17_09">И в этом случае нам необходимо выполнить полное копирование. \nДля этого надо определить метод клонирования у класса <b>Author</b>:</string>
    <string name="lessonsOop17_10">И затем исправим метод <b>clone</b> в классе Book следующим образом:</string>

    <string name="lessonsException18_01"><u>Обработка исключений</u></string>
    <string name="lessonsException18_02">В теме <b>Введение в обработку исключений</b> (Основы Java) были рассмотрены некоторые основные моменты обработки исключений. \nСейчас более подробно поговорим о других моментах, связанных с обработкой исключений.</string>
    <string name="lessonsException18_03"><u>Оператор throws</u></string>
    <string name="lessonsException18_04">Иногда метод, в котором может генерироваться исключение, сам не обрабатывает это исключение. \nВ этом случае в объявлении метода используется оператор <b>throws</b>, который надо обработать при вызове этого метода. \n\nНапример, у нас имеется метод вычисления факториала, и нам надо обработать ситуацию, если в метод передается число меньше <b>1</b>:</string>
    <string name="lessonsException18_05">С помощью оператора <b>throw</b> по условию выбрасывается исключение. \n\nВ то же время метод сам это исключение не обрабатывает с помощью <b>try..catch</b>, поэтому в определении метода используется выражение <b>throws Exception</b>. \n\nТеперь при вызове этого метода нам обязательно надо обработать выбрасываемое исключение:</string>
    <string name="lessonsException18_06">Без обработки исключение у нас возникнет ошибка компиляции, и мы не сможем скомпилировать программу. \nВ качестве альтернативы мы могли бы и не использовать оператор <b>throws</b>, а обработать исключение прямо в методе:</string>

    <string name="lessonsException19_01"><u>Классы исключений</u></string>
    <string name="lessonsException19_02">Базовым классом для всех исключений является класс <b>Throwable</b>. \nОт него уже наследуются два класса: <b>Error</b> и <b>Exception</b>. \n\nВсе остальные классы являются производными от этих двух классов. \n\nКласс <b>Error</b> описывает внутренние ошибки в исполняющей среде <b>Java</b>. \nПрограммист имеет очень ограниченные возможности для обработки подобных ошибок. \n\nСобственно исключения наследуются от класса <b>Exception</b>. \nСреди этих исключений следует выделить класс <b>RuntimeException</b>. \n\n<b>RuntimeException</b> является базовым классом для так называемой группы непроверяемых исключений (unchecked exceptions) - компилятор не проверяет факт обработки таких исключений и их можно не указывать вместе с оператором <b>throws</b> в объявлении метода. \nТакие исключения являются следствием ошибок разработчика, например, неверное преобразование типов или выход за пределы массива.</string>
    <string name="lessonsException19_03">Некоторые из классов непроверяемых исключений: \n\n<b>-ArithmeticException</b>: исключение, возникающее при делении на ноль \n\n<b>-IndexOutOfBoundException</b>: индекс вне границ массива \n\n<b>-IllegalArgumentException</b>: использование неверного аргумента при вызове метода \n\n<b>-NullPointerException</b>: использование пустой ссылки \n\n<b>-NumberFormatException</b>: ошибка преобразования строки в число \n\nВсе остальные классы, образованные от класса <b>Exception</b>, называются проверяемыми исключениями (checked exceptions). \n\nНекоторые из классов проверяемых исключений: \n\n<b>-CloneNotSupportedException</b>: класс, для объекта которого вызывается клонирование, не реализует интерфейс <b>Cloneable</b> \n\n<b>-InterruptedException</b>: поток прерван другим потоком \n\n<b>-ClassNotFoundException</b>: невозможно найти класс \n\nПодобные исключения обрабатываются с помощью конструкции <b>try..catch</b>. \nЛибо можно передать обработку методу, который будет вызывать данный метод, указав исключения после оператора <b>throws</b>:</string>
    <string name="lessonsException19_04">В итоге получается следующая иерархия исключений:</string>
    <string name="lessonsException19_05">Поскольку все классы исключений наследуются от класса <b>Exception</b>, то все они наследуют ряд его методов, которые позволяют получить информацию о характере исключения. \n\nСреди этих методов отметим наиболее важные: \n\n-Метод <b>getMessage()</b> возвращает сообщение об исключении \n\n-Метод <b>getStackTrace()</b> возвращает массив, содержащий трассировку стека исключения \n\n-Метод <b>printStackTrace()</b> отображает трассировку стека \n\nНапример:</string>

    <string name="lessonsException20_01"><u>Создание своих классов исключений</u></string>
    <string name="lessonsException20_02">Хотя имеющиеся в стандартной библиотеке классов <b>Java</b> классы исключений описывают большинство исключительных ситуаций, которые могут возникнуть при выполнении программы, все таки иногда требуется создать свои собственные классы исключений со своей логикой. \n\nЧтобы создать свой класс исключений, надо унаследовать его от класса <b>Exception</b>. \n\nНапример, у нас есть класс, вычисляющий факториал, и нам надо выбрасывать специальное исключение, если число, передаваемое в метод, меньше <b>1</b>:</string>
    <string name="lessonsException20_03">Здесь для определения ошибки, связанной с вычислением факториала, определен класс <b>FactorialException</b>, который наследуется от <b>Exception</b> и который содержит всю информацию о вычислении. \n\nВ конструкторе <b>FactorialException</b> в конструктор базового класса <b>Exception</b> передается сообщение об ошибке: \n<b>super(message)</b>. \nКроме того, отдельное поле предназначено для хранения числа, факториал которого вычисляется. \n\nДля генерации исключения в методе вычисления факториала выбрасывается исключение с помощью оператора <b>throw</b>:\n\nthrow new FactorialException(\"Число не может быть меньше 1\", num). \n\nКроме того, так как это исключение не обрабатывается с помощью <b>try..catch</b>, то мы передаем обработку вызывающему методу, используя оператор <b>throws</b>: \n\npublic static int getFactorial(int num) throws FactorialException \n\nТеперь используем класс в методе <b>main</b>:</string>

    <string name="lessonsCollections01_01"><u>Коллекции</u></string>
    <string name="lessonsCollections01_02">Для хранения наборов данных в <b>Java</b> предназначены массивы. Однако их не всегда удобно использовать, прежде всего потому, что они имеют фиксированную длину. \n\nЭту проблему в <b>Java</b> решают коллекции. Однако суть не только в гибких по размеру наборах объектов, но в и том, что классы коллекций реализуют различные алгоритмы и структуры данных, например, такие как стек, очередь, дерево и ряд других. \n\nКлассы коллекций располагаются в пакете <b>java.util</b>, поэтому перед применением коллекций следует подключить данный пакет. \n\nХотя в <b>Java</b> существует множество коллекций, но все они образуют стройную и логичную систему. \nВо-первых, в основе всех коллекций лежит применение того или иного интерфейса, который определяет базовый функционал. \n\nСреди этих интерфейсов можно выделить следующие:</string>
    <string name="lessonsCollections01_03">Collection</string>
    <string name="lessonsCollections01_04"><b>Collection</b> базовый интерфейс для всех коллекций и других интерфейсов коллекций</string>
    <string name="lessonsCollections01_05">Queue</string>
    <string name="lessonsCollections01_06"><b>Queue</b> наследует интерфейс <b>Collection</b> и представляет функционал для структур данных в виде очереди</string>
    <string name="lessonsCollections01_07">Deque</string>
    <string name="lessonsCollections01_08"><b>Deque</b> наследует интерфейс <b>Queue</b> и представляет функционал для двунаправленных очередей</string>
    <string name="lessonsCollections01_09">List</string>
    <string name="lessonsCollections01_10"><b>List</b> наследует интерфейс <b>Collection</b> и представляет функциональность простых списков</string>
    <string name="lessonsCollections01_11">Set</string>
    <string name="lessonsCollections01_12"><b>Set</b> также расширяет интерфейс <b>Collection</b> и используется для хранения множеств уникальных объектов</string>
    <string name="lessonsCollections01_13">SortedSet</string>
    <string name="lessonsCollections01_14"><b>SortedSet</b> расширяет интерфейс <b>Set</b> для создания сортированных коллекций</string>
    <string name="lessonsCollections01_15">NavigableSet</string>
    <string name="lessonsCollections01_16"><b>NavigableSet</b> расширяет интерфейс <b>SortedSet</b> для создания коллекций, в которых можно осуществлять поиск по соответствию</string>
    <string name="lessonsCollections01_17">Map</string>
    <string name="lessonsCollections01_18"><b>Map</b> предназначен для созданий структур данных в виде словаря, где каждый элемент имеет определенный ключ и значение. \nВ отличие от других интерфейсов коллекций не наследуется от интерфейса <b>Collection</b></string>
    <string name="lessonsCollections01_19">Эти интерфейсы частично реализуются абстрактными классами: \n\n&#9654;<b>AbstractCollection</b>: базовый абстрактный класс для других коллекций, который применяет интерфейс <b>Collection</b> \n\n&#9654;<b>AbstractList</b>: расширяет класс <b>AbstractCollection</b> и применяет интерфейс <b>List</b>, предназначен для создания коллекций в виде списков \n\n&#9654;<b>AbstractSet</b>: расширяет класс <b>AbstractCollection</b> и применяет интерфейс <b>Set</b> для создания коллекций в виде множеств \n\n&#9654;<b>AbstractQueue</b>: расширяет класс <b>AbstractCollection</b> и применяет интерфейс <b>Queue</b>, предназначен для создания коллекций в виде очередей и стеков \n\n&#9654;<b>AbstractSequentialList</b>: также расширяет класс <b>AbstractList</b> и реализует интерфейс <b>List</b>. \nИспользуется для создания связанных списков \n\n&#9654;<b>AbstractMap</b>: применяет интерфейс <b>Map</b>, предназначен для создания наборов по типу словаря с объектами в виде пары <b>ключ-значение</b></string>
    <string name="lessonsCollections01_20">С помощью применения вышеописанных интерфейсов и абстрактных классов в <b>Java</b> реализуется широкая палитра классов коллекций - списки, множества, очереди, отображения и другие, среди которых можно выделить следующие: \n\n&#9654;<b>ArrayList</b>: простой список объектов \n\n&#9654;<b>LinkedList</b>: представляет связанный список \n\n&#9654;<b>ArrayDeque</b>: класс двунаправленной очереди, в которой мы можем произвести вставку и удаление как в начале коллекции, так и в ее конце \n\n&#9654;<b>HashSet</b>: набор объектов или хеш-множество, где каждый элемент имеет ключ - уникальный хеш-код \n\n&#9654;<b>TreeSet</b>: набор отсортированных объектов в виде дерева \n\n&#9654;<b>LinkedHashSet</b>: связанное хеш-множество \n\n&#9654;<b>PriorityQueue</b>: очередь приоритетов \n\n&#9654;<b>HashMap</b>: структура данных в виде словаря, в котором каждый объект имеет уникальный ключ и некоторое значение \n\n&#9654;<b>TreeMap</b>: структура данных в виде дерева, где каждый элемент имеет уникальный ключ и некоторое значение \n\nСхематично всю систему коллекций вкратце можно представить следующим образом:</string>
    <string name="lessonsCollections01_21"><u>Интерфейс Collection</u></string>
    <string name="lessonsCollections01_22">Интерфейс <b>Collection</b> является базовым для всех коллекций, определяя основной функционал:</string>
    <string name="lessonsCollections01_23">Интерфейс <b>Collection</b> является обобщенным и расширяет интерфейс <b>Iterable</b>, поэтому все объекты коллекций можно перебирать в цикле по типу <b>for-each</b>. \n\nСреди методов интерфейса <b>Collection</b> можно выделить следующие: \n\n&#9654;<b>boolean add (E item)</b>: добавляет в коллекцию объект <b>item</b>. \nПри удачном добавлении возвращает <b>true</b>, при неудачном - <b>false</b> \n\n&#9654;<b>boolean addAll (Collection&#60;? extends E&#62; col)</b>: добавляет в коллекцию все элементы из коллекции <b>col</b>. \nПри удачном добавлении возвращает <b>true</b>, при неудачном - <b>false</b> \n\n&#9654;<b>void clear ()</b>: удаляет все элементы из коллекции \n\n&#9654;<b>boolean contains (Object item)</b>: возвращает <b>true</b>, если объект <b>item</b> содержится в коллекции, иначе возвращает <b>false</b> \n\n&#9654;<b>boolean isEmpty ()</b>: возвращает <b>true</b>, если коллекция пуста, иначе возвращает <b>false</b> \n\n&#9654;<b>Iterator&#60;E&#62; iterator ()</b>: возвращает объект <b>Iterator</b> для обхода элементов коллекции \n\n&#9654;<b>boolean remove (Object item)</b>: возвращает <b>true</b>, если объект <b>item</b> удачно удален из коллекции, иначе возвращается <b>false</b> \n\n&#9654;<b>boolean removeAll (Collection&#60;?&#62; col)</b>: удаляет все объекты коллекции <b>col</b> из текущей коллекции. \nЕсли текущая коллекция изменилась, возвращает <b>true</b>, иначе возвращается <b>false</b> \n\n&#9654;<b>boolean retainAll (Collection&#60;?&#62; col)</b>: удаляет все объекты из текущей коллекции, кроме тех, которые содержатся в коллекции <b>col</b>. \nЕсли текущая коллекция после удаления изменилась, возвращает <b>true</b>, иначе возвращается <b>false</b> \n\n&#9654;<b>int size ()</b>: возвращает число элементов в коллекции <b>Object[] toArray ()</b>: возвращает массив, содержащий все элементы коллекции</string>
    <string name="lessonsCollections01_24">Все эти и остальные методы, которые имеются в интерфейсе <b>Collection</b>, реализуются всеми коллекциями, поэтому в целом общие принципы работы с коллекциями будут одни и те же. \n\nЕдинообразный интерфейс упрощает понимание и работу с различными типами коллекций. \nТак, добавление элемента будет производиться с помощью метода <b>add</b>, который принимает добавляемый элемент в качестве параметра. \n\nДля удаления вызывается метод <b>remove()</b>. \n\nМетод <b>clear</b> будет очищать коллекцию, а метод <b>size</b> возвращать количество элементов в коллекции.</string>

    <string name="lessonsCollections02_01"><u>Класс ArrayList и интерфейс List</u></string>
    <string name="lessonsCollections02_02">Для создания простых списков применяется интерфейс <b>List</b>, который расширяет функцональность интерфейса <b>Collection</b>. \nНекоторые наиболее часто используемые методы интерфейса <b>List</b>: \n\n&#9654;<b>void add(int index, E obj)</b>: добавляет в список по индексу <b>index</b> объект <b>obj</b> \n\n&#9654;<b>boolean addAll(int index, Collection&#60;? extends E&#62; col)</b>: добавляет в список по индексу <b>index</b> все элементы коллекции <b>col</b>. \nЕсли в результате добавления список был изменен, то возвращается <b>true</b>, иначе возвращается <b>false</b> \n\n&#9654;<b>E get(int index)</b>: возвращает объект из списка по индексу <b>index</b> \n\n&#9654;<b>int indexOf(Object obj)</b>: возвращает индекс первого вхождения объекта <b>obj</b> в список. \nЕсли объект не найден, то возвращается <b>-1</b> \n\n&#9654;<b>int lastIndexOf(Object obj)</b>: возвращает индекс последнего вхождения объекта <b>obj</b> в список. \nЕсли объект не найден, то возвращается <b>-1</b> \n\n&#9654;<b>ListIterator&#60;E&#62; listIterator ()</b>: возвращает объект <b>ListIterator</b> для обхода элементов списка \n\n&#9654;<b>static &#60;E&#62; List&#60;E&#62; of(элементы)</b>: создает из набора элементов объект <b>List</b> \n\n&#9654;<b>E remove(int index)</b>: удаляет объект из списка по индексу <b>index</b>, возвращая при этом удаленный объект \n\n&#9654;<b>E set(int index, E obj)</b>: присваивает значение объекта <b>obj</b> элементу, который находится по индексу <b>index</b> \n\n&#9654;<b>void sort(Comparator&#60;? super E&#62; comp)</b>: сортирует список с помощью компаратора <b>comp</b> \n\n&#9654;<b>List&#60;E&#62; subList(int start, int end)</b>: получает набор элементов, которые находятся в списке между индексами <b>start</b> и <b>end</b></string>
    <string name="lessonsCollections02_03">По умолчанию в <b>Java</b> есть встроенная реализация этого интерфейса - класс <b>ArrayList</b>. \n\nКласс <b>ArrayList</b> представляет обобщенную коллекцию, которая наследует свою функциональность от класса <b>AbstractList</b> и применяет интерфейс <b>List</b>. \nПроще говоря, <b>ArrayList</b> представляет простой список, аналогичный массиву, за тем исключением, что количество элементов в нем не фиксировано. \n\n<b>ArrayList</b> имеет следующие конструкторы: \n\n&#9654;<b>ArrayList()</b>: создает пустой список \n\n&#9654;<b>ArrayList(Collection &#60;? extends E&#62; col)</b>: создает список, в который добавляются все элементы коллекции <b>col</b>. \n\n&#9654;<b>ArrayList (int capacity)</b>: создает список, который имеет начальную емкость <b>capacity</b> \n\nЕмкость в <b>ArrayList</b> представляет размер массива, который будет использоваться для хранения объектов. \nПри добавлении элементов фактически происходит перераспределение памяти - создание нового массива и копирование в него элементов из старого массива. Изначальное задание емкости <b>ArrayList</b> позволяет снизить подобные перераспределения памяти, тем самым повышая производительность. \n\nИспользуем класс <b>ArrayList</b> и некоторые его методы в программе:</string>
    <string name="lessonsCollections02_04">Консольный вывод программы:</string>
    <string name="lessonsCollections02_05">Здесь объект <b>ArrayList</b> типизируется классом <b>String</b>, поэтому список будет хранить только строки. \n\nПоскольку класс <b>ArrayList</b> применяет интерфейс <b>Collection&#60;E&#62;</b>, то мы можем использовать методы данного интерфейса для управления объектами в списке. \n\Для добавления вызывается метод <b>add</b>. \n\nС его помощью мы можем добавлять объект в конец списка: \n\n<b>people.add(\"Tom\")</b>. \nТакже мы можем добавить объект на определенное место в списке, например, добавим объект на второе место (то есть по индексу <b>1</b>, так как нумерация начинается с нуля): \n\n<b>people.add(1,\"Bob\")</b> \n\nМетод <b>size()</b> позволяет узнать количество объектов в коллекции. \n\nПроверку на наличие элемента в коллекции производится с помощью метода <b>contains</b>. \nА удаление с помощью метода <b>remove</b>. \nИ так же, как и с добавлением, мы можем удалить либо конкретный элемент: \n\n<b>people.remove(\"Tom\");</b>, либо элемент по индексу: \n\n<b>people.remove(0);</b> - удаление первого элемента. \n\nПолучить определенный элемент по индексу мы можем с помощью метода \n\n<b>get(): String person = people.get(1);</b>, а установить элемент по индексу с помощью метода \n\n<b>set: people.set(1,\"Robert\");</b> \n\nС помощью метода <b>toArray()</b> мы можем преобразовать список в массив объектов. \n\nИ поскольку класс <b>ArrayList</b> реализует интерфейс <b>Iterable</b>, то мы можем пробежаться по списку в цикле аля <b>for-each</b>: \n<b>for(String person : people)</b>. \n\nХотя мы можем свободно добавлять в объект <b>ArrayList</b> дополнительные объекты, в отличие от массива, однако в реальности <b>ArrayList</b> использует для хранения объектов опять же массив. \nПо умолчанию данный массив предназначен для <b>10</b> объектов. \n\nЕсли в процессе программы добавляется гораздо больше, то создается новый массив, который может вместить в себя все количество. \n\nПодобные перераспределения памяти уменьшают производительность. \nПоэтому если мы точно знаем, что у нас список не будет содержать больше определенного количества элементов, например, <b>25</b>, то мы можем сразу же явным образом установить это количество, либо в конструкторе: \n\n<b>ArrayList&#60;String&#62; people = new ArrayList&#60;String&#62;(25);</b> \n\nлибо с помощью метода \n\n<b>ensureCapacity: people.ensureCapacity(25);</b></string>

    <string name="lessonsCollections03_01"><u>Очереди и класс ArrayDeque</u></string>
    <string name="lessonsCollections03_02">Очереди представляют структуру данных, работающую по принципу <b>FIFO</b> (first in - first out). То есть чем раньше был добавлен элемент в коллекцию, тем раньше он из нее удаляется. \nЭто стандартная модель однонаправленной очереди. Однако бывают и двунаправленные - то есть такие, в которых мы можем добавить элемент не только в начала, но и в конец. И соответственно удалить элемент не только из конца, но и из начала. \n\nОсобенностью классов очередей является то, что они реализуют специальные интерфейсы <b>Queue</b> или <b>Deque</b>.</string>
    <string name="lessonsCollections03_03"><u>Интерфейс Queue</u></string>
    <string name="lessonsCollections03_04">Обобщенный интерфейс <b>Queue&#60;E&#62;</b> расширяет базовый интерфейс <b>Collection</b> и определяет поведение класса в качестве однонаправленной очереди. \n\nСвою функциональность он раскрывает через следующие методы: \n\n&#9654;<b>E element()</b>: возвращает, но не удаляет, элемент из начала очереди. \nЕсли очередь пуста, генерирует исключение <b>NoSuchElementException</b> \n\n&#9654;<b>boolean offer(E obj)</b>: добавляет элемент <b>obj</b> в конец очереди. \nЕсли элемент удачно добавлен, возвращает <b>true</b>, иначе - <b>false</b> \n\n&#9654;<b>E peek()</b>: возвращает без удаления элемент из начала очереди. \nЕсли очередь пуста, возвращает значение <b>null</b> \n\n&#9654;<b>E poll()</b>: возвращает с удалением элемент из начала очереди. \nЕсли очередь пуста, возвращает значение <b>null</b> \n\n&#9654;<b>E remove()</b>: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение <b>NoSuchElementException</b> \n\nТаким образом, у всех классов, которые реализуют данный интерфейс, будет метод <b>offer</b> для добавления в очередь, метод <b>poll</b> для извлечения элемента из головы очереди, и методы <b>peek</b> и <b>element</b>, позволяющие просто получить элемент из головы очереди.</string>
    <string name="lessonsCollections03_05"><u>Интерфейс Deque</u></string>
    <string name="lessonsCollections03_06">Интерфейс <b>Deque</b> расширяет вышеописанный интерфейс <b>Queue</b> и определяет поведение двунаправленной очереди, которая работает как обычная однонаправленная очередь, либо как стек, действующий по принципу <b>LIFO</b> (последний вошел - первый вышел). \n\nИнтерфейс <b>Deque</b> определяет следующие методы: \n\n&#9654;<b>void addFirst(E obj)</b>: добавляет элемент в начало очереди \n\n&#9654;<b>void addLast(E obj)</b>: добавляет элемент <b>obj</b> в конец очереди \n\n&#9654;<b>E getFirst()</b>: возвращает без удаления элемент из головы очереди. \nЕсли очередь пуста, генерирует исключение <b>NoSuchElementException</b> \n\n&#9654;<b>E getLast()</b>: возвращает без удаления последний элемент очереди. \nЕсли очередь пуста, генерирует исключение <b>NoSuchElementException</b> \n\n&#9654;<b>boolean offerFirst(E obj)</b>: добавляет элемент <b>obj</b> в самое начало очереди. \nЕсли элемент удачно добавлен, возвращает <b>true</b>, иначе - <b>false</b> \n\n&#9654;<b>boolean offerLast(E obj)</b>: добавляет элемент <b>obj</b> в конец очереди. \nЕсли элемент удачно добавлен, возвращает <b>true</b>, иначе - <b>false</b> \n\n&#9654;<b>E peekFirst()</b>: возвращает без удаления элемент из начала очереди. \nЕсли очередь пуста, возвращает значение <b>null</b> \n\n&#9654;<b>E peekLast()</b>: возвращает без удаления последний элемент очереди. \nЕсли очередь пуста, возвращает значение <b>null</b> \n\n&#9654;<b>E pollFirst()</b>: возвращает с удалением элемент из начала очереди. \nЕсли очередь пуста, возвращает значение <b>null</b> \n\n&#9654;<b>E pollLast()</b>: возвращает с удалением последний элемент очереди. \nЕсли очередь пуста, возвращает значение <b>null</b> \n\n&#9654;<b>E pop()</b>: возвращает с удалением элемент из начала очереди. \nЕсли очередь пуста, генерирует исключение <b>NoSuchElementException</b> \n\n&#9654;<b>void push(E element)</b>: добавляет элемент в самое начало очереди \n\n&#9654;<b>E removeFirst()</b>: возвращает с удалением элемент из начала очереди. \nЕсли очередь пуста, генерирует исключение <b>NoSuchElementException</b> \n\n&#9654;<b>E removeLast()</b>: возвращает с удалением элемент из конца очереди. \nЕсли очередь пуста, генерирует исключение <b>NoSuchElementException</b> \n\n&#9654;<b>boolean removeFirstOccurrence(Object obj)</b>: удаляет первый встреченный элемент <b>obj</b> из очереди. \nЕсли удаление произшло, то возвращает <b>true</b>, иначе возвращает <b>false</b>. \n\n&#9654;<b>boolean removeLastOccurrence(Object obj)</b>: удаляет последний встреченный элемент <b>obj</b> из очереди. \nЕсли удаление произшло, то возвращает <b>true</b>, иначе возвращает <b>false</b>. \n\nТаким образом, наличие методов <b>pop</b> и <b>push</b> позволяет классам, реализующим этот элемент, действовать в качестве стека. \nВ тоже время имеющийся функционал также позволяет создавать двунаправленные очереди, что делает классы, применяющие данный интерфейс, довольно гибкими.</string>
    <string name="lessonsCollections03_07"><u>Класс ArrayDeque</u></string>
    <string name="lessonsCollections03_08">В <b>Java</b> очереди представлены рядом классов. Одни из низ - класс <b>ArrayDeque&#60;E&#62;</b>. \n\nЭтот класс представляют обобщенную двунаправленную очередь, наследуя функционал от класса <b>AbstractCollection</b> и применяя интерфейс <b>Deque</b>. \n\nВ классе <b>ArrayDeque</b> определены следующие конструкторы: \n\n&#9654;<b>ArrayDeque()</b>: создает пустую очередь \n\n&#9654;<b>ArrayDeque(Collection&#60;? extends E&#62; col)</b>: создает очередь, наполненную элементами из коллекции <b>col</b> \n\n&#9654;<b>ArrayDeque(int capacity)</b>: создает очередь с начальной емкостью <b>capacity</b>. \nЕсли мы явно не указываем начальную емкость, то емкость по умолчанию будет равна <b>16</b> \n\nПример использования класса:</string>

    <string name="lessonsCollections04_01"><u>Класс LinkedList</u></string>
    <string name="lessonsCollections04_02">Обобщенный класс <b>LinkedList&#60;E&#62;</b> представляет структуру данных в виде связанного списка. \nОн наследуется от класса <b>AbstractSequentialList</b> и реализует интерфейсы <b>List</b>, <b>Dequeue</b> и <b>Queue</b>. \nТо есть он соединяет функциональность работы со списком и фукциональность очереди. \n\nКласс <b>LinkedList</b> имеет следующие конструкторы: \n\n&#9654;<b>LinkedList()</b>: создает пустой список \n\n&#9654;<b>LinkedList(Collection&#60;? extends E&#62; col)</b>: создает список, в который добавляет все элементы коллекции <b>col</b></string>
    <string name="lessonsCollections04_03"><b>LinkedList</b> содержит все те методы, которые определены в интерфейсах <b>List, Queue, Deque</b>. \n\nНекоторые из них: \n\n&#9654;<b>addFirst() / offerFirst()</b>: добавляет элемент в начало списка \n\n&#9654;<b>addLast() / offerLast()</b>: добавляет элемент в конец списка \n\n&#9654;<b>removeFirst() / pollFirst()</b>: удаляет первый элемент из начала списка \n\n&#9654;<b>removeLast() / pollLast()</b>: удаляет последний элемент из конца списка \n\n&#9654;<b>getFirst() / peekFirst()</b>: получает первый элемент \n\n&#9654;<b>getLast() / peekLast()</b>: получает последний элемент \n\nРассмотрим применение связанного списка:</string>
    <string name="lessonsCollections04_04">Здесь создаются и используются два списка: для строк и для объектов класса <b>Person</b>. \n\nПри этом в дополнение к методам <b>addFirst/removeLast</b> и т.д., нам также доступны стандартные методы, определенные в интерфейсе <b>Collection</b>: \n<b>add()</b>, \n<b>remove</b>, \n<b>contains</b>, \n<b>size</b> и другие. \n\nПоэтому мы можем использовать разные методы для одного и того же действия. \n\nНапример, добавление в самое начало списка можно сделать так: \n\n<b>states.addFirst(\"Spain\");</b>, \n\nа можно сделать так: \n\n<b>states.add(0,\"Spain\");</b></string>

    <string name="lessonsCollections05_01"><u>Интерфейс Set и класс HashSet</u></string>
    <string name="lessonsCollections05_02">Интерфейс Set расширяет интерфейс <b>Collection</b> и представляет набор уникальных элементов. \n<b>Set</b> не добавляет новых методов, только вносит изменения унаследованные. \n\nВ частности, метод <b>add()</b> добавляет элемент в коллекцию и возвращает <b>true</b>, если в коллекции еще нет такого элемента. \n\nОбобщенный класс <b>HashSet</b> представляет хеш-таблицу. Он наследует свой функционал от класса <b>AbstractSet</b>, а также реализует интерфейс <b>Set</b>. \n\nХеш-таблица представляет такую структуру данных, в которой все объекты имеют уникальный ключ или хеш-код. \nДанный ключ позволяет уникально идентифицировать объект в таблице.</string>
    <string name="lessonsCollections05_03">Для создания объекта <b>HashSet</b> можно воспользоваться одним из следующих конструкторов: \n\n&#9654;<b>HashSet()</b>: создает пустой список \n\n&#9654;<b>HashSet(Collection&#60;? extends E&#62; col)</b>: создает хеш-таблицу, в которую добавляет все элементы коллекции <b>col</b> \n\n&#9654;<b>HashSet(int capacity)</b>: параметр <b>capacity</b> указывает начальную емкость таблицы, которая по умолчанию равна <b>16</b> \n\n&#9654;<b>HashSet(int capacity, float koef)</b>: параметр <b>koef</b> или коэффициент заполнения, значение которого должно быть в пределах от <b>0.0</b> до <b>1.0</b>, указывает, насколько должна быть заполнена емкость объектами прежде чем произойдет ее расширение. \nНапример, коэффициент <b>0.75</b> указывает, что при заполнении емкости на <b>3/4</b> произойдет ее расширение. \n\nКласс <b>HashSet</b> не добавляет новых методов, реализуя лишь те, что объявлены в родительских классах и применяемых интерфейсах:</string>

    <string name="lessonsCollections06_01"><u>SortedSet</u></string>
    <string name="lessonsCollections06_02">Интерфейс <b>SortedSet</b> предназначен для создания коллекций, который хранят элементы в отсортированном виде (сортировка по возрастанию). \n\n<b>SortedSet</b> расширяет интерфейс <b>Set</b>, поэтому такая коллекция опять же хранит только уникальные значения. \n\n<b>SortedSet</b> предоставляет следующие методы: \n\n&#9654;<b>E first()</b>: возвращает первый элемент набора \n\n&#9654;<b>E last()</b>: возвращает последний элемент набора \n\n&#9654;<b>SortedSet&#60;E&#62; headSet(E end)</b>: возвращает объект <b>SortedSet</b>, который содержит все элементы первичного набора до элемента <b>end</b> \n\n&#9654;<b>SortedSet&#60;E&#62; subSet(E start, E end)</b>: возвращает объект <b>SortedSet</b>, который содержит все элементы первичного набора между элементами <b>start</b> и <b>end</b> \n\n&#9654;<b>SortedSet&#60;E&#62; tailSet(E start)</b>: возвращает объект <b>SortedSet</b>, который содержит все элементы первичного набора, начиная с элемента <b>start</b></string>
    <string name="lessonsCollections06_03"><u>NavigableSet</u></string>
    <string name="lessonsCollections06_04">Интерфейс <b>NavigableSet</b> расширяет интерфейс <b>SortedSet</b> и позволяет извлекать элементы на основании их значений. \n\n<b>NavigableSet</b> определяет следующие методы: \n\n&#9654;<b>E ceiling(E obj)</b>: ищет в наборе наименьший элемент <b>e</b>, который больше <b>obj (e &#62;=obj)</b>. \nЕсли такой элемент найден, то он возвращается в качестве результата. \nИначе возвращается <b>null</b>. \n\n&#9654;<b>E floor(E obj)</b>: ищет в наборе наибольший элемент <b>e</b>, который меньше элемента <b>obj (e &#60;=obj)</b>. \nЕсли такой элемент найден, то он возвращается в качестве результата. \nИначе возвращается <b>null</b>. \n\n&#9654;<b>E higher(E obj)</b>: ищет в наборе наименьший элемент <b>e</b>, который больше элемента <b>obj (e &#62;obj)</b>. \nЕсли такой элемент найден, то он возвращается в качестве результата. \nИначе возвращается <b>null</b>. \n\n&#9654;<b>E lower(E obj)</b>: ищет в наборе наибольший элемент <b>e</b>, который меньше элемента <b>obj (e &#60;obj)</b>. \nЕсли такой элемент найден, то он возвращается в качестве результата. \nИначе возвращается <b>null</b>. \n\n&#9654;<b>E pollFirst()</b>>: возвращает первый элемент и удаляет его из набора \n\n&#9654;<b>E pollLast()</b>: возвращает последний элемент и удаляет его из набора NavigableSet&#60;E&#62; descendingSet(): возвращает объект <b>NavigableSet</b>, который содержит все элементы первичного набора <b>NavigableSet</b> в обратном порядке \n\n&#9654;<b>NavigableSet&#60;E&#62; headSet(E upperBound, boolean incl)</b>: возвращает объект <b>NavigableSet</b>, который содержит все элементы первичного набора <b>NavigableSet</b> до <b>upperBound</b>. \nПараметр <b>incl</b> при значении <b>true</b>, позволяет включить в выходной набор элемент <b>upperBound</b> \n\n&#9654;<b>NavigableSet&#60;E&#62; tailSet(E lowerBound, boolean incl)</b>: возвращает объект <b>NavigableSet</b>, который содержит все элементы первичного набора <b>NavigableSet</b>, начиная с <b>lowerBound</b>. \nПараметр <b>incl</b> при значении <b>true</b>, позволяет включить в выходной набор элемент <b>lowerBound</b> \n\n&#9654;<b>NavigableSet&#60;E&#62; subSet(E lowerBound, boolean lowerIncl, E upperBound, boolean highIncl)</b>: возвращает объект <b>NavigableSet</b>, который содержит все элементы первичного набора <b>NavigableSet</b> от <b>lowerBound</b> до <b>upperBound</b>.</string>
    <string name="lessonsCollections06_05"><u>TreeSet</u></string>
    <string name="lessonsCollections06_06">Обобщенный класс <b>TreeSet&#60;E&#62;</b> представляет структуру данных в виде дерева, в котором все объекты хранятся в отсортированном виде по возрастанию. \n<b>TreeSet</b> является наследником класса <b>AbstractSet</b> и реализует интерфейс <b>NavigableSet</b>, а следовательно, и интерфейс <b>SortedSet</b>. \n\nВ классе <b>TreeSet</b> определены следующие конструкторы: \n\n&#9654;<b>TreeSet()</b>>: создает пустое дерево \n\n&#9654;<b>TreeSet(Collection&#60;? extends E&#62; col)</b>>: создает дерево, в которое добавляет все элементы коллекции <b>col</b> \n\n&#9654;<b>TreeSet(SortedSet &#60;E&#62; set)</b>>: создает дерево, в которое добавляет все элементы сортированного набора <b>set</b> \n\n&#9654;<b>TreeSet(Comparator&#60;? super E&#62; comparator)</b>: создает пустое дерево, где все добавляемые элементы впоследствии будут отсортированы компаратором. \n\nTreeSet поддерживает все стандартные методы для вставки и удаления элементов:</string>
    <string name="lessonsCollections06_07">И поскольку при вставке объекты сразу же сортируются по возрастанию, то при выводе в цикле <b>for</b> мы получим отсортированный набор:</string>
    <string name="lessonsCollections06_08">Так как <b>TreeSet</b> реализует интерфейс <b>NavigableSet</b>, а через него и <b>SortedSet</b>, то мы можем применить к структуре дерева различные методы:</string>

    <string name="lessonsCollections07_01"><u>Интерфейсы Comparable и Comparator. Сортировка</u></string>
    <string name="lessonsCollections07_02">В прошлой теме была рассмотрена работа коллекции <b>TreeSet</b>, типизированной объектами <b>String</b>. \n\nПри добавлении новых элементов объект <b>TreeSet</b> автоматически проводит сортировку, помещая новый объект на правильное для него место. Однако со строками все понятно. \n\nА что если бы мы использовали не строки, а свои классы, например, следующий класс <b>Person</b>:</string>
    <string name="lessonsCollections07_03">Объект <b>TreeSet</b> мы не сможем типизировать данным классом, поскольку в случае добавления объектов <b>TreeSet</b> не будет знать, как их сравнивать, и следующий кусок кода не будет работать:</string>
    <string name="lessonsCollections07_04">При выполнении этого кода мы столкнемся с ошибкой, которая скажет, что объект <b>Person</b> не может быть преобразован к типу \n<b>java.lang.Comparable</b>. \n\nДля того, чтобы объекты <b>Person</b> можно было сравнить и сортировать, они должны применять интерфейс <b>Comparable&#60;E&#62;</b>. \nПри применении интерфейса он типизируется текущим классом. \n\nПрименим его к классу Person:</string>
    <string name="lessonsCollections07_05">Интерфейс <b>Comparable</b> содержит один единственный метод \n<b>int compareTo(E item)</b>, который сравнивает текущий объект с объектом, переданным в качестве параметра. \n\nЕсли этот метод возвращает отрицательное число, то текущий объект будет располагаться перед тем, который передается через параметр. \nЕсли метод вернет положительное число, то, наоборот, после второго объекта. Если метод возвратит ноль, значит, оба объекта равны. \n\nВ данном случае мы не возвращаем явным образом никакое число, а полагаемся на встроенный механизм сравнения, который есть у класса <b>String</b>. \nНо мы также можем определить и свою логику, например, сравнивать по длине имени:</string>
    <string name="lessonsCollections07_06">Теперь мы можем типизировать <b>TreeSet</b> типом <b>Person</b> и добавлять в дерево соответствующие объекты:</string>
    <string name="lessonsCollections07_07"><u>Интерфейс Comparator</u></string>
    <string name="lessonsCollections07_08">Однако перед нами может возникнуть проблема, что если разработчик не реализовал в своем классе, который мы хотим использовать, интерфейс <b>Comparable</b>, либо реализовал, но нас не устраивает его функциональность, и мы хотим ее переопределить? \n\nНа этот случай есть еще более гибкий способ, предполагающий применение интерфейса <b>Comparator&#60;E&#62;</b>. \n\nИнтерфейс <b>Comparator</b> содержит ряд методов, ключевым из которых является метод <b>compare()</b>:</string>
    <string name="lessonsCollections07_09">Метод <b>compare</b> также возвращает числовое значение - если оно отрицательное, то объект a предшествует объекту <b>b</b>, иначе - наоборот. \nА если метод возвращает ноль, то объекты равны. \n\nДля применения интерфейса нам вначале надо создать класс компаратора, который реализует этот интерфейс:</string>
    <string name="lessonsCollections07_10">Здесь опять же проводим сравнение по строкам. \n\nТеперь используем класс компаратора для создания объекта <b>TreeSet</b>:</string>
    <string name="lessonsCollections07_11">Для создания <b>TreeSet</b> здесь используется одна из версий конструктора, которая в качестве параметра принимает компаратор. \n\nТеперь вне зависимости от того, реализован ли в классе <b>Person</b> интерфейс <b>Comparable</b>, логика сравнения и сортировки будет использоваться та, которая определена в классе компаратора.</string>
    <string name="lessonsCollections07_12"><u>Сортировка по нескольким критериям</u></string>
    <string name="lessonsCollections07_13">Начиная с <b>JDK 8</b> в механизм работы компараторов были внесены некоторые дополнения. \n\nВ частности, теперь мы можем применять сразу несколько компараторов по принципу приоритета. \n\nНапример, изменим класс <b>Person</b> следующим образом:</string>
    <string name="lessonsCollections07_14">Здесь добавлено поле для хранения возраста пользователя. \n\nИ, допустим, нам надо отсортировать пользователей по имени и по возрасту. \n\nДля этого определим два компаратора:</string>
    <string name="lessonsCollections07_15">Интерфейс компаратора определяет специальный метод по умолчанию <b>thenComparing</b>, который позволяет использовать цепочки компараторов для сортировки набора:</string>
    <string name="lessonsCollections07_16">Консольный вывод:</string>
    <string name="lessonsCollections07_17">В данном случае сначала применяется сортировка по имени, а потом по возрасту.</string>

    <string name="lessonsCollections08_01"><u>Интерфейс Map и класс HashMap</u></string>
    <string name="lessonsCollections08_02">Интерфейс <b>Map&#60;K, V&#62;</b> представляет отображение или иначе говоря словарь, где каждый элемент представляет пару <b>\"ключ-значение\"</b>. \nПри этом все ключи уникальные в рамках объекта <b>Map</b>. Такие коллекции облегчают поиск элемента, если нам известен ключ - уникальный идентификатор объекта. \n\nСледует отметить, что в отличие от других интерфейсов, которые представляют коллекции, интерфейс <b>Map</b> НЕ расширяет интерфейс <b>Collection</b>.</string>
    <string name="lessonsCollections08_03">Среди методов интерфейса <b>Map</b> можно выделить следующие: \n\n&#9654;<b>void clear()</b>: очищает коллекцию \n\n&#9654;<b>boolean containsKey(Object k)</b>: возвращает <b>true</b>, если коллекция содержит ключ <b>k</b> \n\n&#9654;<b>boolean containsValue(Object v)</b>: возвращает <b>true</b>, если коллекция содержит значение <b>v</b> \n\n&#9654;<b>Set&#60;Map.Entry&#60;K, V&#62;entrySet()</b>: возвращает набор элементов коллекции. \nВсе элементы представляют объект <b>Map.Entry</b> \n\n&#9654;<b>boolean equals(Object obj)</b>: возвращает <b>true</b>, если коллекция идентична коллекции, передаваемой через параметр <b>obj</b> \n\n&#9654;<b>boolean isEmpty</b>: возвращает <b>true</b>, если коллекция пуста \n\n&#9654;<b>V get(Object k)</b>: возвращает значение объекта, ключ которого равен <b>k</b>. \nЕсли такого элемента не окажется, то возвращается значение <b>null</b> \n\n&#9654;<b>V getOrDefault(Object k, V defaultValue)</b>: возвращает значение объекта, ключ которого равен <b>k</b>. \nЕсли такого элемента не окажется, то возвращается значение <b>defaultVlue</b> \n\n&#9654;<b>V put(K k, V v)</b>: помещает в коллекцию новый объект с ключом <b>k</b> и значением <b>v</b>. \nЕсли в коллекции уже есть объект с подобным ключом, то он перезаписывается. \nПосле добавления возвращает предыдущее значение для ключа <b>k</b>, если он уже был в коллекции. \nЕсли же ключа еще не было в коллекции, то возвращается значение <b>null</b> \n\n&#9654;<b>V putIfAbsent(K k, V v)</b>: помещает в коллекцию новый объект с ключом <b>k</b> и значением <b>v</b>, если в коллекции еще нет элемента с подобным ключом. \n\n&#9654;<b>Set&#60;K&#62; keySet()</b>: возвращает набор всех ключей отображения \n\n&#9654;<b>Collection&#60;V&#62; values()</b>: возвращает набор всех значений отображения \n\n&#9654;<b>void putAll(Map&#60;? extends K, ? extends V&#62; map)</b>: добавляет в коллекцию все объекты из отображения <b>map</b> \n\n&#9654;<b>V remove(Object k)</b>: удаляет объект с ключом <b>k</b> \n\n&#9654;<b>int size()</b>: возвращает количество элементов коллекции</string>
    <string name="lessonsCollections08_04">Чтобы положить объект в коллекцию, используется метод <b>put</b>, а чтобы получить по ключу - метод <b>get</b>. \nРеализация интерфейса <b>Map</b> также позволяет получить наборы как ключей, так и значений. \n\nА метод <b>entrySet()</b> возвращает набор всех элементов в виде объектов <b>Map.Entry&#60;K, V&#62;</b>. \n\nОбобщенный интерфейс <b>Map.Entry&#60;K, V&#62;</b> представляет объект с ключом типа <b>K</b> и значением типа <b>V</b> и определяет следующие методы: \n\n&#9654;<b>boolean equals(Object obj)</b>: возвращает <b>true</b>>, если объект <b>obj</b>, представляющий интерфейс <b>Map.Entry</b>, идентичен текущему \n\n&#9654;<b>K getKey()</b>: возвращает ключ объекта отображения \n\n&#9654;<b>V getValue()</b>: возвращает значение объекта отображения \n\n&#9654;<b>V setValue(V v)</b>: устанавливает для текущего объекта значение \n\n&#9654;<b>v int hashCode()</b>: возвращает хеш-код данного объекта \n\nПри переборе объектов отображения мы будем оперировать этими методами для работы с ключами и значениями объектов.</string>
    <string name="lessonsCollections08_05"><u>Классы отображений. HashMap</u></string>
    <string name="lessonsCollections08_06">Базовым классом для всех отображений является абстрактный класс <b>AbstractMap</b>, который реализует большую часть методов интерфейса <b>Map</b>. \n\nНаиболее распространенным классом отображений является <b>HashMap</b>, который реализует интерфейс <b>Map</b> и наследуется от класса <b>AbstractMap</b>. \n\nПример использования класса:</string>
    <string name="lessonsCollections08_07">Чтобы добавить или заменить элемент, используется метод <b>put</b>, либо <b>replace</b>, а чтобы получить его значение по ключу - метод <b>get</b>. \n\nС помощью других методов интерфейса <b>Map</b> также производятся другие манипуляции над элементами: перебор, получение ключей, значений, удаление.</string>

    <string name="lessonsCollections09_01"><u>Интерфейсы SortedMap и NavigableMap. Класс TreeMap</u></string>
    <string name="lessonsCollections09_02">Для создания отображений <b>Java</b> также предоставляет ряд дополнительных интерфейсов: \n<b>SortedMap</b> и <b>NavigableMap</b></string>
    <string name="lessonsCollections09_03"><u>SortedMap</u></string>
    <string name="lessonsCollections09_04">Интерфейс <b>SortedMap</b> расширяет <b>Map</b> и создает отображение, в котором все элементы отсортированы в порядке возрастания их ключей. \n\n<b>SortedMap</b> добавляет ряд методов: \n\n&#9654;<b>K firstKey()</b>: возвращает ключ первого элемента отображения \n\n&#9654;<b>K lastKey()</b>: возвращает ключ последнего элемента отображения \n\n&#9654;<b>SortedMap&#60;K, V&#62; headMap(K end)</b>: возвращает отображение <b>SortedMap</b>, которые содержит все элементы оригинального <b>SortedMap</b> вплоть до элемента с ключом <b>end</b> \n\n&#9654;<b>SortedMap&#60;K, V&#62; tailMap(K start)</b>: возвращает отображение <b>SortedMap</b>, которые содержит все элементы оригинального <b>SortedMap</b>, начиная с элемента с ключом <b>start</b> \n\n&#9654;<b>SortedMap&#60;K, V&#62; subMap(K start, K end)</b>: возвращает отображение <b>SortedMap</b>, которые содержит все элементы оригинального <b>SortedMap</b> вплоть от элемента с ключом <b>start</b> до элемента с ключом <b>end</b></string>
    <string name="lessonsCollections09_05"><u>NavigableMap</u></string>
    <string name="lessonsCollections09_06">Интерфейс <b>NavigableMap</b> расширяет интерфейс <b>SortedMap</b> и обеспечивает возможность получения элементов отображения относительно других элементов. \n\nЕго основные методы: \n\n&#9654;<b>Map.Entry&#60;K, V&#62; ceilingEntry(K obj)</b>: возвращает элемент с наименьшим ключом <b>k</b>, который больше или равен ключу <b>obj (k >=obj)</b>. \nЕсли такого ключа нет, то возвращается <b>null</b>. \n\n&#9654;<b>Map.Entry&#60;K, V&#62; floorEntry(K obj)</b>: возвращает элемент с наибольшим ключом <b>k</b>, который меньше или равен ключу <b>obj (k &#60;=obj)</b>. \nЕсли такого ключа нет, то возвращается <b>null</b>. \n\n&#9654;<b>Map.Entry&#60;K, V&#62; higherEntry()</b>: возвращает элемент с наименьшим ключом <b>k</b>, который больше ключа <b>obj (k >obj)</b>. \nЕсли такого ключа нет, то возвращается <b>null</b>. \n\n&#9654;<b>Map.Entry&#60;K, V&#62; lowerEntry()</b>: возвращает элемент с наибольшим ключом <b>k</b>, который меньше ключа <b>obj (k &#62;obj)</b>. \nЕсли такого ключа нет, то возвращается <b>null</b>. \n\n&#9654;<b>Map.Entry&#60;K, V&#62; firstEntry()</b>: возвращает первый элемент отображения \n\n&#9654;<b>Map.Entry&#60;K, V&#62; lastEntry()</b>: возвращает последний элемент отображения \n\n&#9654;<b>Map.Entry&#60;K, V&#62; pollFirstEntry()</b>>: возвращает и одновременно удаляет первый элемент из отображения \n\n&#9654;<b>Map.Entry&#60;K, V&#62; pollLastEntry()</b>: возвращает и одновременно удаляет последний элемент из отображения \n\n&#9654;<b>K ceilingKey(K obj)</b>>: возвращает наименьший ключ <b>k</b>, который больше или равен ключу <b>obj (k &#62;=obj)</b>. \nЕсли такого ключа нет, то возвращается <b>null</b>. \n\n&#9654;<b>K floorKey(K obj)</b>: возвращает наибольший ключ <b>k</b>, который меньше или равен ключу <b>obj (k &#60;=obj)</b>. \nЕсли такого ключа нет, то возвращается <b>null</b>. \n\n&#9654;<b>K lowerKey(K obj)</b>: возвращает наибольший ключ <b>k</b>, который меньше ключа <b>obj (k &#60;obj)</b>. \nЕсли такого ключа нет, то возвращается <b>null</b>. \n\n&#9654;<b>K higherKey(K obj)</b>: возвращает наименьший ключ <b>k</b>, который больше ключа <b>obj (k &#62;obj)</b>. \nЕсли такого ключа нет, то возвращается <b>null</b>. \n\n&#9654;<b>NavigableSet&#60;K&#62; descendingKeySet()</b>: возвращает объект <b>NavigableSet</b>, который содержит все ключи отображения в обратном порядке \n\n&#9654;<b>NavigableMap&#60;K, V&#62; descendingMap()</b>: возвращает отображение <b>NavigableMap</b>, которое содержит все элементы в обратном порядке \n\n&#9654;<b>NavigableSet&#60;K&#62; navigableKeySet()</b>: возвращает объект <b>NavigableSet</b>, который содержит все ключи отображения \n\n&#9654;<b>NavigableMap&#60;K, V&#62; headMap(K upperBound, boolean incl)</b>: возвращает отображение <b>NavigableMap</b>, которое содержит все элементы оригинального <b>NavigableMap</b> вплоть от элемента с ключом <b>upperBound</b>. \nПараметр <b>incl</b> при значении <b>true</b> указывает, что элемент с ключом <b>upperBound</b> также включается в выходной набор. \n\n&#9654;<b>NavigableMap&#60;K, V&#62; tailMap(K lowerBound, boolean incl)</b>: возвращает отображение <b>NavigableMap</b>, которое содержит все элементы оригинального <b>NavigableMap</b>, начиная с элемента с ключом <b>lowerBound</b>. \nПараметр <b>incl</b> при значении <b>true</b> указывает, что элемент с ключом <b>lowerBound</b> также включается в выходной набор. \n\n&#9654;<b>NavigableMap&#60;K, V&#62; subMap(K lowerBound, boolean lowIncl, K upperBound, boolean highIncl)</b>: возвращает отображение <b>NavigableMap</b>, которое содержит все элементы оригинального <b>NavigableMap</b> от элемента с ключом <b>lowerBound</b> до элемента с ключом <b>upperBound</b>. \nПараметры <b>lowIncl</b> и <b>highIncl</b> при значении <b>true</b> включают в выходной набор элементы с ключами <b>lowerBound</b> и <b>upperBound</b> соответственно</string>
    <string name="lessonsCollections09_07"><u>TreeMap</u></string>
    <string name="lessonsCollections09_08">Класс <b>TreeMap &#60;K, V&#62;</b> представляет отображение в виде дерева. \nОн наследуется от класса <b>AbstractMap</b> и реализует интерфейс <b>NavigableMap</b>, а следовательно, также и интерфейс <b>SortedMap</b>. \n\nПоэтому в отличие от коллекции <b>HashMap</b> в <b>TreeMap</b> все объекты автоматически сортируются по возрастанию их ключей. \n\nКласс <b>TreeMap</b> имеет следующие конструкторы: \n\n&#9654;<b>TreeMap()</b>: создает пустое отображение в виде дерева \n\n&#9654;<b>TreeMap(Map&#60;? extends K,​? extends V&#62; map)</b>: создает дерево, в которое добавляет все элементы из отображения <b>map</b> \n\n&#9654;<b>TreeMap(SortedMap&#60;K, ? extends V&#62; smap)</b>: создает дерево, в которое добавляет все элементы из отображения <b>smap</b> \n\n&#9654;<b>TreeMap(Comparator&#60;? super K&#62; comparator)</b>: создает пустое дерево, где все добавляемые элементы впоследствии будут отсортированы компаратором. \n\nИспользуем класс в программе:</string>
    <string name="lessonsCollections09_09">Кроме собственно методов интерфейса <b>Map</b> класс <b>TreeMap</b> реализует методы интерфейса <b>NavigableMap</b>. \n\nНапример, мы можем получить все объекты до или после определенного ключа с помощью методов <b>headMap</b> и <b>tailMap</b>. \nТакже мы можем получить первый и последний элементы и провести ряд дополнительных манипуляций с объектами.</string>

    <string name="lessonsCollections10_01"><u>Итераторы</u></string>
    <string name="lessonsCollections10_02">Одним из ключевых методов интерфейса <b>Collection</b> является метод <b>Iterator&#60;E&#62; iterator()</b>. \nОн возвращает итератор - то есть объект, реализующий интерфейс <b>Iterator</b>. \n\nИнтерфейс <b>Iterator</b> имеет следующее определение:</string>
    <string name="lessonsCollections10_03">Реализация интерфейса предполагает, что с помощью вызова метода <b>next()</b> можно получить следующий элемент. \nС помощью метода <b>hasNext()</b> можно узнать, есть ли следующий элемент, и не достигнут ли конец коллекции. \nИ если элементы еще имеются, то <b>hasNext()</b> вернет значение <b>true</b>. \n\nМетод <b>hasNext()</b> следует вызывать перед методом <b>next()</b>, так как при достижении конца коллекции метод <b>next()</b> выбрасывает исключение <b>NoSuchElementException</b>. \nИ метод <b>remove()</b> удаляет текущий элемент, который был получен последним вызовом <b>next()</b>. \n\nИспользуем итератор для перебора коллекции <b>ArrayList</b>:</string>
    <string name="lessonsCollections10_04">Интерфейс <b>Iterator</b> предоставляет ограниченный функционал. Гораздо больший набор методов предоставляет другой итератор - интерфейс <b>ListIterator</b>. \n\nДанный итератор используется классами, реализующими интерфейс <b>List</b>, то есть классами <b>LinkedList, ArrayList</b> и др.\n\nИнтерфейс <b>ListIterator</b> расширяет интерфейс <b>Iterator</b> и определяет ряд дополнительных методов: \n\n&#9654;<b>void add(E obj)</b>: вставляет объект <b>obj</b> перед элементом, который должен быть возвращен следующим вызовом <b>next()</b> \n\n&#9654;<b>boolean hasNext()</b>: возвращает <b>true</b>, если в коллекции имеется следующий элемент, иначе возвращает <b>false</b> \n\n&#9654;<b>boolean hasPrevious()</b>: возвращает <b>true</b>, если в коллекции имеется предыдущий элемент, иначе возвращает <b>false</b> \n\n&#9654;<b>E next()</b>: возвращает текущий элемент и переходит к следующему, если такого нет, то генерируется исключение <b>NoSuchElementException</b> \n\n&#9654;<b>E previous()</b>: возвращает текущий элемент и переходит к предыдущему, если такого нет, то генерируется исключение <b>NoSuchElementException</b> \n\n&#9654;<b>int nextIndex()</b>: возвращает индекс следующего элемента. \nЕсли такого нет, то возвращается размер списка \n\n&#9654;<b>int previousIndex()</b>: возвращает индекс предыдущего элемента. \nЕсли такого нет, то возвращается число <b>-1</b> \n\n&#9654;<b>void remove()</b>: удаляет текущий элемент из списка. \nТаким образом, этот метод должен быть вызван после методов <b>next()</b> или <b>previous()</b>, иначе будет сгенерировано исключение <b>IlligalStateException</b> \n\n&#9654;<b>void set(E obj)</b>: присваивает текущему элементу, выбранному вызовом методов <b>next()</b> или <b>previous()</b>, ссылку на объект <b>obj</b> \n\nИспользуем <b>ListIterator</b>:</string>


    <string-array name="basics_java">
        <item><i>1) Первая программа</i></item>
        <item><i>2) Переменные</i></item>
        <item><i>3) Типы данных</i></item>
        <item><i>4) Консольный ввод</i></item>
        <item><i>5) Арифметические операции</i></item>
        <item><i>6) Поразрядные операции</i></item>
        <item><i>7) Условные выражения</i></item>
        <item><i>8) Операции присваивания</i></item>
        <item><i>9) Преобразование базовых типов данных</i></item>
        <item><i>10) Условные конструкции</i></item>
        <item><i>11) Циклы</i></item>
        <item><i>12) Массивы</i></item>
        <item><i>13) Методы</i></item>
        <item><i>14) Параметры методов</i></item>
        <item><i>15) Оператор return</i></item>
        <item><i>16) Перегрузка методов</i></item>
        <item><i>17) Рекурсивные функции</i></item>
        <item><i>18) Обработка исключений</i></item>
    </string-array>
    <string-array name="oop_java">
        <item><i>1) Классы и объекты</i></item>
        <item><i>2) Пакеты</i></item>
        <item><i>3) Модификаторы доступа и инкапсуляция</i></item>
        <item><i>4) Статический модификатор </i></item>
        <item><i>5) Объекты как параметры методов</i></item>
        <item><i>6) Внутренние и вложенные классы</i></item>
        <item><i>7) Наследование</i></item>
        <item><i>8) Абстрактные классы</i></item>
        <item><i>9) Иерархия наследования</i></item>
        <item><i>10) Интерфейсы</i></item>
        <item><i>11) Интерфейсы в механизме обратного вызова</i></item>
        <item><i>12) Перечисления enum</i></item>
        <item><i>13) Класс Object и его методы</i></item>
        <item><i>14) Обобщения (Generics)</i></item>
        <item><i>15) Ограничения обобщений</i></item>
        <item><i>16) Наследование и обобщения</i></item>
        <item><i>17) Ссылочные типы и копирование объектов</i></item>
        <item><i>18) Обработка исключений</i></item>
        <item><i>19) Классы исключений</i></item>
        <item><i>20) Создание своих классов исключений</i></item>
    </string-array>
    <string-array name="collections_java">
        <item><i>1) Типы коллекций. Интерфейс Collection</i></item>
        <item><i>2) Класс ArrayList и интерфейс List</i></item>
        <item><i>3) Очереди и класс ArrayDeque</i></item>
        <item><i>4) Класс LinkedList</i></item>
        <item><i>5) Интерфейс Set и класс HashSet</i></item>
        <item><i>6) SortedSet, NavigableSet, TreeSet</i></item>
        <item><i>7) Интерфейсы Comparable и Comparator</i></item>
        <item><i>8) Интерфейс Map и класс HashMap</i></item>
        <item><i>9) Интерфейсы SortedMap и NavigableMap</i></item>
        <item><i>10) Итераторы</i></item>
    </string-array>
    <string-array name="other_java">
        <item><i>1) Потоки ввода-вывода</i></item>
        <item><i>2) Чтение и запись файлов</i></item>
        <item><i>3) Закрытие потоков</i></item>
        <item><i>4) Классы ByteArrayInputStream и ByteArrayOutputStream</i></item>
        <item><i>5) Буферизованные потоки</i></item>
        <item><i>6) Форматируемый ввод и вывод</i></item>
        <item><i>7) Классы DataOutputStream и DataInputStream</i></item>
        <item><i>8) Чтение и запись текстовых файлов</i></item>
        <item><i>9) Буферизация символьных потоков</i></item>
        <item><i>10) Сериализация</i></item>
        <item><i>11) Класс File. Работа с файлами и каталогами</i></item>
        <item><i>12) Работа с ZIP-архивами</i></item>
        <item><i>13) Класс Console</i></item>
        <item><i>14) Работа со строками</i></item>
        <item><i>15) Основные операции со строками</i></item>
        <item><i>16) StringBuffer и StringBuilder</i></item>
        <item><i>17) Регулярные выражения</i></item>
        <item><i>18) Лямбда-выражения</i></item>
        <item><i>19) Лямбды как параметры и результаты методов</i></item>
        <item><i>20) Встроенные функциональные интерфейсы</i></item>
        <item><i>21) Класс Thread</i></item>
        <item><i>22) Создание и выполнение потоков</i></item>
        <item><i>23) Завершение и прерывание потока</i></item>
        <item><i>24) Синхронизация потоков. Оператор synchronized</i></item>
        <item><i>25) Методы wait и notify</i></item>
        <item><i>26) Семафоры</i></item>
        <item><i>27) Обмен между потоками. Класс Exchanger</i></item>
        <item><i>28) Класс Phaser</i></item>
        <item><i>29) Блокировки. ReentrantLock</i></item>
        <item><i>30) Условия в блокировках</i></item>
        <item><i>31) Введение в Stream API</i></item>
        <item><i>32) Создание потока данных</i></item>
        <item><i>33) Фильтрация, перебор элементов и отображение</i></item>
        <item><i>34) Сортировка</i></item>
        <item><i>35) Получение подпотока и объединение потоков</i></item>
        <item><i>36) Методы skip и limit</i></item>
        <item><i>37) Операции сведения</i></item>
        <item><i>38) Метод reduce</i></item>
        <item><i>39) Тип Optional</i></item>
        <item><i>40) Метод collect</i></item>
        <item><i>41) Группировка</i></item>
        <item><i>42) Параллельные потоки</i></item>
        <item><i>43) Параллельные операции над массивами</i></item>
        <item><i>44) Создание модуля</i></item>
        <item><i>45) Зависимые модули</i></item>
        <item><i>46) Взаимодействие между модулями</i></item>
        <item><i>47) Математические вычисления и класс Math</i></item>
        <item><i>48) Большие числа BigInteger и BigDecimal</i></item>
        <item><i>49) Работа с датами. LocalDate</i></item>
    </string-array>
</resources>
